// Generated by Haxe 3.4.4
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Color = { __ename__ : true, __constructs__ : ["Red","Green","Blue","Black","White","Gray","LightBlue","Purple","Yellow","DarkGray","LightGray"] };
Color.Red = ["Red",0];
Color.Red.toString = $estr;
Color.Red.__enum__ = Color;
Color.Green = ["Green",1];
Color.Green.toString = $estr;
Color.Green.__enum__ = Color;
Color.Blue = ["Blue",2];
Color.Blue.toString = $estr;
Color.Blue.__enum__ = Color;
Color.Black = ["Black",3];
Color.Black.toString = $estr;
Color.Black.__enum__ = Color;
Color.White = ["White",4];
Color.White.toString = $estr;
Color.White.__enum__ = Color;
Color.Gray = ["Gray",5];
Color.Gray.toString = $estr;
Color.Gray.__enum__ = Color;
Color.LightBlue = ["LightBlue",6];
Color.LightBlue.toString = $estr;
Color.LightBlue.__enum__ = Color;
Color.Purple = ["Purple",7];
Color.Purple.toString = $estr;
Color.Purple.__enum__ = Color;
Color.Yellow = ["Yellow",8];
Color.Yellow.toString = $estr;
Color.Yellow.__enum__ = Color;
Color.DarkGray = ["DarkGray",9];
Color.DarkGray.toString = $estr;
Color.DarkGray.__enum__ = Color;
Color.LightGray = ["LightGray",10];
Color.LightGray.toString = $estr;
Color.LightGray.__enum__ = Color;
var Drawer = function(stage) {
	this.stage = stage;
	this.wallGraphics = new PIXI.Graphics();
	stage.addChild(this.wallGraphics);
	this.bitmaps = [];
	var _g = 0;
	while(_g < 24) {
		var i = _g++;
		this.bitmaps[i] = [];
		var _g1 = 0;
		while(_g1 < 50) {
			var j = _g1++;
			var bitmap = new PIXI.extras.BitmapText("",{ font : "font", tint : 16777215});
			this.bitmaps[i][j] = bitmap;
			bitmap.position.set(j * 15,i * 25 - 5);
			stage.addChild(bitmap);
		}
	}
};
Drawer.__name__ = true;
Drawer.colorToInt = function(color) {
	switch(color[1]) {
	case 0:
		return 16711680;
	case 1:
		return 65280;
	case 2:
		return 255;
	case 3:
		return 0;
	case 4:
		return 16777215;
	case 5:
		return 8421504;
	case 6:
		return 4376052;
	case 7:
		return 9060294;
	case 8:
		return 16776960;
	case 9:
		return 4210752;
	case 10:
		return 11579568;
	}
};
Drawer.prototype = {
	clear: function() {
		this.clearLines(0,24);
		this.wallGraphics.clear();
	}
	,clearLines: function(start,amount) {
		var _g1 = start;
		var _g = start + amount;
		while(_g1 < _g) {
			var i = _g1++;
			var _g2 = 0;
			while(_g2 < 50) {
				var j = _g2++;
				this.bitmaps[i][j].text = "";
			}
		}
	}
	,setMouseHelp: function(text) {
		this.clearLines(22,2);
		var yy = 22;
		if(this.getAmountOfLines(0,22,"Examine: " + text) == 1) {
			++yy;
		}
		var col = 0;
		if(text != "") {
			col = Drawer.colorToInt(Color.DarkGray);
		}
		this.setMultiBackground(0,yy,"Examine:".length,col);
		this.setMultiBackground(0,yy == 22 ? 23 : 22,"Examine:".length,0);
		if(text != "") {
			this.drawText(0,yy,"Examine: " + text);
		}
	}
	,setMultiBackground: function(x,y,width,col) {
		var _g1 = x;
		var _g = x + width;
		while(_g1 < _g) {
			var i = _g1++;
			this.setBackground(i,y,col);
		}
	}
	,setWorldView: function(screenX,screenY,worldX,worldY,width,height) {
		this.screenX = screenX;
		this.screenY = screenY;
		this.worldX = worldX;
		this.worldY = worldY;
		this.worldWidth = width;
		this.worldHeight = height;
	}
	,setWorldCharacter: function(x,y,character,color,notInView) {
		if(notInView == null) {
			notInView = false;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x >= this.worldX && y >= this.worldY && x < this.worldX + this.worldWidth && y < this.worldY + this.worldHeight) {
			this.setCharacter(x - this.worldX + this.screenX,y - this.worldY + this.screenY,character,color,notInView ? 0.5 : 1);
		}
	}
	,setWorldWall: function(x,y,color,notInView) {
		if(notInView == null) {
			notInView = false;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x >= this.worldX && y >= this.worldY && x < this.worldX + this.worldWidth && y < this.worldY + this.worldHeight) {
			this.setBackground(x - this.worldX + this.screenX,y - this.worldY + this.screenY,color,notInView ? 0.5 : 1);
		}
	}
	,setCharacter: function(x,y,character,color,alpha) {
		if(alpha == null) {
			alpha = 1.0;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x < 0 || y < 0 || x >= 50 || y >= 24) {
			return;
		}
		this.bitmaps[y][x].text = character;
		this.bitmaps[y][x].tint = color;
		this.bitmaps[y][x].alpha = alpha;
	}
	,setBackground: function(x,y,color,alpha) {
		if(alpha == null) {
			alpha = 1.0;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x < 0 || y < 0 || x >= 50 || y >= 24) {
			return;
		}
		this.wallGraphics.beginFill(color,alpha);
		this.wallGraphics.drawRect(x * 15,y * 25,15,25);
		this.wallGraphics.endFill();
	}
	,drawText: function(x,y,text,color,wrap,maxWidth,getMaxX) {
		if(maxWidth == null) {
			maxWidth = -1;
		}
		if(wrap == null) {
			wrap = true;
		}
		if(color == null) {
			color = 16777215;
		}
		var lines = this.splitIntoLines(x,y,text,wrap,maxWidth,getMaxX);
		var minX = x;
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			var _g2 = 0;
			var _g1 = line.length;
			while(_g2 < _g1) {
				var i = _g2++;
				this.setCharacter(x,y,line.charAt(i),color);
				++x;
			}
			++y;
			x = minX;
		}
		return lines.length;
	}
	,splitIntoLines: function(x,y,text,wrap,maxWidth,getMaxX) {
		if(maxWidth == null) {
			maxWidth = -1;
		}
		if(wrap == null) {
			wrap = true;
		}
		var minX = x;
		var maxX;
		if(maxWidth == -1) {
			maxX = 50;
		} else {
			var val2 = x + maxWidth;
			if(val2 < 50) {
				maxX = val2;
			} else {
				maxX = 50;
			}
		}
		if(getMaxX == null) {
			getMaxX = function(i,j) {
				return i;
			};
		}
		var lines = text.split("\n");
		var finalLines = [];
		var finalLine = "";
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			var words = line.split(" ");
			var _g1 = 0;
			while(_g1 < words.length) {
				var word = words[_g1];
				++_g1;
				if(x + word.length >= getMaxX(maxX,finalLines.length)) {
					finalLines.push(finalLine);
					finalLine = "";
					x = minX;
					++y;
				}
				if(finalLine != "") {
					finalLine += " ";
				}
				finalLine += word;
				x += word.length + 1;
			}
			finalLines.push(finalLine);
			finalLine = "";
			++y;
			x = minX;
		}
		return finalLines;
	}
	,getAmountOfLines: function(x,y,text,wrap,maxWidth,getMaxX) {
		if(maxWidth == null) {
			maxWidth = -1;
		}
		if(wrap == null) {
			wrap = true;
		}
		return this.splitIntoLines(x,y,text,wrap,maxWidth,getMaxX).length;
	}
	,__class__: Drawer
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,__class__: EReg
};
var Focusable = function(keyboard,world,game) {
	this.keyboard = keyboard;
	this.world = world;
	this.game = game;
};
Focusable.__name__ = true;
Focusable.prototype = {
	get_showsWorld: function() {
		return false;
	}
	,update: function() {
	}
	,__class__: Focusable
};
var Game = function(application,stage,gameRect) {
	this.application = application;
	this.stage = stage;
	this.rect = gameRect;
	this.drawer = new Drawer(stage);
	this.keyboard = new Keyboard();
	this.world = new World(this.drawer);
	this.mouse = new Mouse(stage,this.world);
	this.player = new Player(this.keyboard,this.world,this);
	this.world.player = this.player;
	this.focusedElement = this.player;
	this.info = new ui_InfoDisplay(this.keyboard,this.world,this,this.player);
	this.world.info = this.info;
	this.drawWorld();
};
Game.__name__ = true;
Game.prototype = {
	update: function(timeMod) {
		this.keyboard.update();
		this.focusedElement.update();
		this.postUpdate();
	}
	,focus: function(element,redrawIfWorld) {
		if(redrawIfWorld == null) {
			redrawIfWorld = true;
		}
		this.focusedElement = element;
		if(element.get_showsWorld() && redrawIfWorld) {
			this.drawWorld();
		}
	}
	,drawWorld: function() {
		this.drawer.clear();
		this.world.draw();
	}
	,postUpdate: function() {
		this.keyboard.postUpdate();
		if(this.focusedElement.get_showsWorld()) {
			var mouseWorldPos = this.world.toWorldPoint(this.mouse.mousePosition);
			if(mouseWorldPos != null) {
				this.drawer.setMouseHelp(this.world.getQuickExamine(mouseWorldPos));
			} else {
				this.drawer.setMouseHelp("");
			}
		}
	}
	,beforeStep: function() {
		this.drawer.clear();
		this.info.clear();
		this.world.preUpdate();
	}
	,afterStep: function() {
		this.world.update();
		this.info.processInfo(this.drawer);
	}
	,__class__: Game
};
var GameLoader = function(then) {
	this.loader = new PIXI.loaders.Loader();
	this.loader.add("fonts/font-export.fnt");
	this.loader["use"](function(res,next) {
		next();
	});
	this.loader.load(then);
};
GameLoader.__name__ = true;
GameLoader.prototype = {
	update: function() {
		console.log(this.loader.progress + "% loaded");
	}
	,__class__: GameLoader
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Keyboard = function() {
	var _gthis = this;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var i = _g1++;
		_g.push(false);
	}
	this.pressed = _g;
	var _g11 = [];
	var _g2 = 0;
	while(_g2 < 256) {
		var i1 = _g2++;
		_g11.push(false);
	}
	this.down = _g11;
	window.addEventListener("keydown",function(event) {
		var keyCode = event.keyCode;
		if(keyCode < 256) {
			_gthis.pressed[keyCode] = true;
			_gthis.down[keyCode] = true;
		}
	},false);
	window.addEventListener("keyup",function(event1) {
		var keyCode1 = event1.keyCode;
		if(keyCode1 < 256) {
			_gthis.down[keyCode1] = false;
		}
	},false);
};
Keyboard.__name__ = true;
Keyboard.getLetterCode = function(letter) {
	var code = HxOverrides.cca(letter,0);
	if(code >= 97 && code <= 122) {
		code -= 32;
	}
	return code;
};
Keyboard.prototype = {
	anyConfirm: function() {
		if(!this.pressed[32]) {
			return this.pressed[13];
		} else {
			return true;
		}
	}
	,anyBack: function() {
		if(!this.pressed[27]) {
			return this.pressed[8];
		} else {
			return true;
		}
	}
	,update: function() {
	}
	,postUpdate: function() {
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			this.pressed[i] = false;
		}
	}
	,leftKey: function() {
		if(!this.pressed[37]) {
			return this.pressed[Keyboard.getLetterCode("A")];
		} else {
			return true;
		}
	}
	,rightKey: function() {
		if(!this.pressed[39]) {
			return this.pressed[Keyboard.getLetterCode("D")];
		} else {
			return true;
		}
	}
	,upKey: function() {
		if(!this.pressed[38]) {
			return this.pressed[Keyboard.getLetterCode("W")];
		} else {
			return true;
		}
	}
	,downKey: function() {
		if(!this.pressed[40]) {
			return this.pressed[Keyboard.getLetterCode("S")];
		} else {
			return true;
		}
	}
	,__class__: Keyboard
};
var pixi_plugins_app_Application = function() {
	this._animationFrameId = null;
	this.pixelRatio = 1;
	this.autoResize = true;
	this.transparent = false;
	this.antialias = false;
	this.forceFXAA = false;
	this.roundPixels = false;
	this.legacy = false;
	this.clearBeforeRender = true;
	this.preserveDrawingBuffer = false;
	this.backgroundColor = 16777215;
	this.width = window.innerWidth;
	this.height = window.innerHeight;
	this.position = "static";
};
pixi_plugins_app_Application.__name__ = true;
pixi_plugins_app_Application.prototype = {
	start: function(rendererType,parentDom,canvasElement) {
		if(rendererType == null) {
			rendererType = "auto";
		}
		if(canvasElement == null) {
			this.canvas = window.document.createElement("canvas");
			this.canvas.style.width = this.width + "px";
			this.canvas.style.height = this.height + "px";
			this.canvas.style.position = this.position;
		} else {
			this.canvas = canvasElement;
		}
		if(this.autoResize) {
			window.onresize = $bind(this,this._onWindowResize);
		}
		var renderingOptions = { };
		renderingOptions.width = this.width | 0;
		renderingOptions.height = this.height | 0;
		renderingOptions.view = this.canvas;
		renderingOptions.backgroundColor = this.backgroundColor;
		renderingOptions.resolution = this.pixelRatio;
		renderingOptions.antialias = this.antialias;
		renderingOptions.forceFXAA = this.forceFXAA;
		renderingOptions.autoResize = this.autoResize;
		renderingOptions.transparent = this.transparent;
		renderingOptions.clearBeforeRender = this.clearBeforeRender;
		renderingOptions.preserveDrawingBuffer = this.preserveDrawingBuffer;
		renderingOptions.roundPixels = this.roundPixels;
		renderingOptions.legacy = this.legacy;
		if(rendererType == null) {
			this.app = new PIXI.Application(renderingOptions);
		} else if(rendererType == "canvas") {
			renderingOptions.forceCanvas = true;
			this.app = new PIXI.Application(renderingOptions);
		} else {
			this.app = new PIXI.Application(renderingOptions);
		}
		this.stage = this.app.stage;
		this.renderer = this.app.renderer;
		if(parentDom == null) {
			window.document.body.appendChild(this.app.view);
		} else {
			parentDom.appendChild(this.app.view);
		}
		this.app.ticker.add($bind(this,this._onRequestAnimationFrame));
	}
	,_onWindowResize: function(event) {
		this.width = window.innerWidth;
		this.height = window.innerHeight;
		this.app.renderer.resize(this.width,this.height);
		this.canvas.style.width = this.width + "px";
		this.canvas.style.height = this.height + "px";
		if(this.onResize != null) {
			this.onResize();
		}
	}
	,_onRequestAnimationFrame: function() {
		if(this.onUpdate != null) {
			this.onUpdate(this.app.ticker.deltaTime);
		}
	}
	,__class__: pixi_plugins_app_Application
};
var Main = function() {
	pixi_plugins_app_Application.call(this);
	this.init();
};
Main.__name__ = true;
Main.main = function() {
	new Main();
};
Main.__super__ = pixi_plugins_app_Application;
Main.prototype = $extend(pixi_plugins_app_Application.prototype,{
	init: function() {
		var _gthis = this;
		this.autoResize = false;
		this.onUpdate = $bind(this,this.update);
		this.backgroundColor = 0;
		this.clearBeforeRender = true;
		this.width = 750;
		this.height = 600;
		this.initConfig();
		pixi_plugins_app_Application.prototype.start.call(this);
		this.gameRect = new common_Rectangle(0,0,750,600);
		this.loader = new GameLoader(function() {
			console.log("loaded");
			_gthis.loader = null;
			_gthis.game = new Game(_gthis,_gthis.stage,_gthis.gameRect);
		});
		this.canvas.addEventListener("contextmenu",function(ev) {
			ev.preventDefault();
			return false;
		});
	}
	,initConfig: function() {
		try {
			var params = haxe_web_Request.getParams();
		} catch( e ) {
		}
	}
	,update: function(elapsedTime) {
		if(this.game != null) {
			this.game.update(elapsedTime);
		} else if(this.loader != null) {
			this.loader.update();
		}
	}
	,__class__: Main
});
Math.__name__ = true;
var Mouse = function(stage,world) {
	this.mousePosition = new common_Point(-1,-1);
	this.mouseRawPosition = new common_Point(-1,-1);
	var _gthis = this;
	stage.interactive = true;
	stage.on("pointermove",function(e) {
		var point = e.data.getLocalPosition(stage);
		var tmp = new common_Point(Math.floor(point.x),Math.floor(point.y));
		_gthis.mouseRawPosition = tmp;
		_gthis.mousePosition = new common_Point(_gthis.mouseRawPosition.x / 15 | 0,_gthis.mouseRawPosition.y / 25 | 0);
	});
};
Mouse.__name__ = true;
Mouse.prototype = {
	__class__: Mouse
};
var Pathfinder = function(world) {
	this.world = world;
};
Pathfinder.__name__ = true;
Pathfinder.prototype = {
	find: function(fromPosition,isGoal,all) {
		if(all == null) {
			all = true;
		}
		var _g = [];
		var _g2 = 0;
		var _g1 = this.world.width;
		while(_g2 < _g1) {
			var i = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.world.height;
			while(_g5 < _g4) {
				var j = _g5++;
				_g3.push(false);
			}
			_g.push(_g3);
		}
		var visited = _g;
		var queue = new de_polygonal_ds_ArrayedQueue();
		var firstDirection = new haxe_ds_ObjectMap();
		var totalDistance = new haxe_ds_ObjectMap();
		var foundPositions = [];
		if(queue.capacity == queue.mSize) {
			queue.grow();
		}
		queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = fromPosition;
		visited[fromPosition.x][fromPosition.y] = true;
		firstDirection.set(fromPosition,null);
		totalDistance.set(fromPosition,0);
		while(queue.mSize != 0) {
			if(true != queue.mSize > 0) {
				throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("queue is empty" + " (size > 0)",{ fileName : "ArrayedQueue.hx", lineNumber : 166, className : "de.polygonal.ds.ArrayedQueue", methodName : "dequeue"}));
			}
			var x = queue.mData[queue.mFront++];
			if(queue.mFront == queue.capacity) {
				queue.mFront = 0;
			}
			queue.mSize--;
			var queueItem = x;
			var firstDir = firstDirection.h[queueItem.__id__];
			var thisDistance = totalDistance.h[queueItem.__id__];
			if(queueItem != fromPosition && isGoal(queueItem)) {
				foundPositions.push({ point : queueItem, inDirection : firstDir, distance : thisDistance});
				if(!all) {
					break;
				}
			}
			if(queueItem == fromPosition || !common_ArrayExtensions.any(this.world.elementsAtPosition(queueItem),function(elem) {
				return elem.get_isBlocking();
			})) {
				if(queueItem.x > 0 && !visited[queueItem.x - 1][queueItem.y]) {
					visited[queueItem.x - 1][queueItem.y] = true;
					var newPoint = new common_Point(queueItem.x - 1,queueItem.y);
					var v = firstDir == null ? common_Direction.Left : firstDir;
					firstDirection.set(newPoint,v);
					var v1 = thisDistance + 1;
					totalDistance.set(newPoint,v1);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint;
				}
				if(queueItem.y > 0 && !visited[queueItem.x][queueItem.y - 1]) {
					visited[queueItem.x][queueItem.y - 1] = true;
					var newPoint1 = new common_Point(queueItem.x,queueItem.y - 1);
					var v2 = firstDir == null ? common_Direction.Up : firstDir;
					firstDirection.set(newPoint1,v2);
					var v3 = thisDistance + 1;
					totalDistance.set(newPoint1,v3);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint1;
				}
				if(queueItem.x < this.world.width - 1 && !visited[queueItem.x + 1][queueItem.y]) {
					visited[queueItem.x + 1][queueItem.y] = true;
					var newPoint2 = new common_Point(queueItem.x + 1,queueItem.y);
					var v4 = firstDir == null ? common_Direction.Right : firstDir;
					firstDirection.set(newPoint2,v4);
					var v5 = thisDistance + 1;
					totalDistance.set(newPoint2,v5);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint2;
				}
				if(queueItem.y < this.world.height - 1 && !visited[queueItem.x][queueItem.y + 1]) {
					visited[queueItem.x][queueItem.y + 1] = true;
					var newPoint3 = new common_Point(queueItem.x,queueItem.y + 1);
					var v6 = firstDir == null ? common_Direction.Down : firstDir;
					firstDirection.set(newPoint3,v6);
					var v7 = thisDistance + 1;
					totalDistance.set(newPoint3,v7);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint3;
				}
			}
		}
		return foundPositions;
	}
	,isVisible: function(firstPosition,secondPosition,onlyViewBlocking,cornersAreBlocking) {
		if(cornersAreBlocking == null) {
			cornersAreBlocking = true;
		}
		if(onlyViewBlocking == null) {
			onlyViewBlocking = true;
		}
		var _gthis = this;
		var checkIfBlocking = function(elem) {
			if(onlyViewBlocking) {
				return elem.get_isViewBlocking();
			} else {
				return elem.get_isBlocking();
			}
		};
		var checkPoint = function(y,x) {
			if(firstPosition.x == x && firstPosition.y == y || secondPosition.x == x && secondPosition.y == y) {
				return false;
			}
			return common_ArrayExtensions.any(_gthis.world.elementsAtPosition(new common_Point(x,y)),checkIfBlocking);
		};
		var x1 = firstPosition.x;
		var y1 = firstPosition.y;
		var x2 = secondPosition.x;
		var y2 = secondPosition.y;
		var i;
		var ystep;
		var xstep;
		var error;
		var errorprev;
		var y3 = y1;
		var x3 = x1;
		var ddy;
		var ddx;
		var dx = x2 - x1;
		var dy = y2 - y1;
		if(checkPoint(y1,x1)) {
			return false;
		}
		if(dy < 0) {
			ystep = -1;
			dy = -dy;
		} else {
			ystep = 1;
		}
		if(dx < 0) {
			xstep = -1;
			dx = -dx;
		} else {
			xstep = 1;
		}
		ddy = 2 * dy;
		ddx = 2 * dx;
		if(ddx >= ddy) {
			error = dx;
			errorprev = error;
			var _g1 = 0;
			var _g = dx;
			while(_g1 < _g) {
				var i1 = _g1++;
				x3 += xstep;
				error += ddy;
				if(error > ddx) {
					y3 += ystep;
					error -= ddx;
					if(error + errorprev < ddx) {
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
					} else if(error + errorprev > ddx) {
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
					} else if(cornersAreBlocking) {
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
					}
				}
				if(checkPoint(y3,x3)) {
					return false;
				}
				errorprev = error;
			}
		} else {
			error = dy;
			errorprev = error;
			var _g11 = 0;
			var _g2 = dy;
			while(_g11 < _g2) {
				var i2 = _g11++;
				y3 += ystep;
				error += ddx;
				if(error > ddy) {
					x3 += xstep;
					error -= ddy;
					if(error + errorprev < ddy) {
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
					} else if(error + errorprev > ddy) {
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
					} else if(cornersAreBlocking) {
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
					}
				}
				if(checkPoint(y3,x3)) {
					return false;
				}
				errorprev = error;
			}
		}
		return true;
	}
	,__class__: Pathfinder
};
var Player = function(keyboard,world,game) {
	Focusable.call(this,keyboard,world,game);
	this.ownBody = new worldElements_creatures_Human(world,new common_Point(1,1));
	world.addElement(this.ownBody);
	this.controllingBody = this.ownBody;
	this.statusEffectsMenuKey = Keyboard.getLetterCode("e");
};
Player.__name__ = true;
Player.__super__ = Focusable;
Player.prototype = $extend(Focusable.prototype,{
	get_showsWorld: function() {
		return true;
	}
	,update: function() {
		var xMove = 0;
		var yMove = 0;
		if(this.keyboard.leftKey()) {
			--xMove;
		}
		if(this.keyboard.rightKey()) {
			++xMove;
		}
		if(this.keyboard.upKey()) {
			--yMove;
		}
		if(this.keyboard.downKey()) {
			++yMove;
		}
		var moveDirection = null;
		if(xMove == -1) {
			moveDirection = common_Direction.Left;
		} else if(xMove == 1) {
			moveDirection = common_Direction.Right;
		} else if(yMove == -1) {
			moveDirection = common_Direction.Up;
		} else if(yMove == 1) {
			moveDirection = common_Direction.Down;
		}
		if(moveDirection != null) {
			if(this.controllingBody.movement.canMove(this.world,this.controllingBody,moveDirection)) {
				this.game.beforeStep();
				this.controllingBody.movement.moveInDirection(this.world,this.controllingBody,moveDirection);
				this.controllingBody.hasMoved = true;
				this.game.afterStep();
			}
		} else if(this.keyboard.pressed[this.statusEffectsMenuKey]) {
			this.showStatusEffects();
		}
	}
	,showStatusEffects: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.controllingBody.statusEffects;
		while(_g1 < _g2.length) {
			var statusEffect = _g2[_g1];
			++_g1;
			_g.push(new ui_MenuItem(statusEffect.name,statusEffect.getText(),function() {
			}));
		}
		var statusEffectMenuItems = _g;
		var menu;
		statusEffectMenuItems.push(new ui_MenuItem("Close Menu","",function() {
			menu.close();
		}));
		menu = new ui_Menu(this.game.drawer,this.keyboard,this.world,this.game,this,"Status Effects",statusEffectMenuItems,this.statusEffectsMenuKey);
		this.game.focus(menu);
	}
	,__class__: Player
});
var Std = function() { };
Std.__name__ = true;
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = true;
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
var World = function(drawer) {
	this.viewY = 0;
	this.viewX = 0;
	this.height = 20;
	this.width = 50;
	this.drawer = drawer;
	this.pathfinder = new Pathfinder(this);
	this.elements = [];
	var _g = [];
	var _g2 = 0;
	var _g1 = this.width;
	while(_g2 < _g1) {
		var i = _g2++;
		var _g3 = [];
		var _g5 = 0;
		var _g4 = this.height;
		while(_g5 < _g4) {
			var j = _g5++;
			_g3.push([]);
		}
		_g.push(_g3);
	}
	this.elementsByPosition = _g;
	this.elements.push(new worldElements_Wall(this,new common_Point(0,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(1,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(2,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(3,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(2,1)));
	this.elements.push(new worldElements_Wall(this,new common_Point(2,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(4,1)));
	this.elements.push(new worldElements_Wall(this,new common_Point(3,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(4,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(5,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(6,1)));
	this.elements.push(new worldElements_Wall(this,new common_Point(3,1)));
	this.elements.push(new worldElements_creatures_Rat(this,new common_Point(5,4)));
};
World.__name__ = true;
World.prototype = {
	addElement: function(element) {
		this.elements.push(element);
	}
	,addToElementsAtPosition: function(element,position) {
		this.elementsByPosition[position.x][position.y].push(element);
	}
	,removeFromElementsAtPosition: function(element,position) {
		HxOverrides.remove(this.elementsByPosition[position.x][position.y],element);
	}
	,preUpdate: function() {
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.preUpdate();
		}
	}
	,update: function() {
		this.removeElementsWhereNeeded();
		this.extraUpdates = [];
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.update();
		}
		while(this.extraUpdates.length > 0) {
			this.removeElementsWhereNeeded();
			var processExtraUpdates = this.extraUpdates.slice();
			this.extraUpdates = [];
			var _g2 = 0;
			while(_g2 < processExtraUpdates.length) {
				var elem = processExtraUpdates[_g2];
				++_g2;
				elem.preUpdate();
				elem.update(true);
			}
		}
		this.removeElementsWhereNeeded();
		var _g3 = 0;
		var _g11 = this.elements;
		while(_g3 < _g11.length) {
			var element1 = _g11[_g3];
			++_g3;
			element1.postUpdate();
		}
		this.removeElementsWhereNeeded();
		this.draw();
	}
	,requestExtraUpdate: function(elem) {
		this.extraUpdates.push(elem);
	}
	,removeElementsWhereNeeded: function() {
		var i = this.elements.length - 1;
		while(i >= 0) {
			var element = this.elements[i];
			if(element.shouldRemove()) {
				this.removeFromElementsAtPosition(element,element.position);
				this.elements.splice(i,1);
			}
			--i;
		}
	}
	,draw: function() {
		var _gthis = this;
		this.drawer.setWorldView(0,2,this.viewX,this.viewY,50,20);
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.isCurrentlyVisible = false;
			if(this.pathfinder.isVisible(this.player.controllingBody.position,element.position,true)) {
				element.draw(this.drawer,false);
				element.seenByPlayer = true;
				element.isCurrentlyVisible = true;
			} else {
				var nowSeen = false;
				if(element.get_isEasierVisible()) {
					var anyIndirectlyVisible = [false];
					this.forEachDirectionFromPoint(element.position,(function(anyIndirectlyVisible1) {
						return function(p) {
							if(_gthis.pathfinder.isVisible(_gthis.player.controllingBody.position,p,true) && _gthis.noBlockingElementsAt(p)) {
								anyIndirectlyVisible1[0] = true;
							}
						};
					})(anyIndirectlyVisible));
					if(anyIndirectlyVisible[0]) {
						nowSeen = true;
						element.isCurrentlyVisible = true;
						element.draw(this.drawer,false);
						element.seenByPlayer = true;
					}
				}
				if(!nowSeen && element.seenByPlayer) {
					element.draw(this.drawer,true);
					element.isCurrentlyVisible = true;
				}
			}
		}
		var _g2 = 0;
		var _g11 = this.elements;
		while(_g2 < _g11.length) {
			var element1 = _g11[_g2];
			++_g2;
			if(js_Boot.__instanceof(element1,worldElements_Wall)) {
				var wall = element1;
				if(!wall.seenByPlayer) {
					var allAroundSeen = [true];
					this.forEachDirectionFromPoint(wall.position,(function(allAroundSeen1) {
						return function(p1) {
							if(_gthis.noBlockingElementsAt(p1) || common_ArrayExtensions.any(_gthis.elementsAtPosition(p1),(function() {
								return function(elem) {
									if(elem.get_isViewBlocking()) {
										return !elem.seenByPlayer;
									} else {
										return false;
									}
								};
							})())) {
								allAroundSeen1[0] = false;
							}
						};
					})(allAroundSeen));
					if(allAroundSeen[0]) {
						wall.seenByPlayer = true;
						wall.draw(this.drawer,true);
						wall.isCurrentlyVisible = true;
					}
				}
			}
		}
	}
	,positionInDirection: function(position,direction) {
		var newPosition = new common_Point(position.x,position.y);
		switch(direction[1]) {
		case 0:
			newPosition.x -= 1;
			break;
		case 1:
			newPosition.x += 1;
			break;
		case 2:
			newPosition.y -= 1;
			break;
		case 3:
			newPosition.y += 1;
			break;
		}
		if(this.isPositionInWorld(newPosition)) {
			return newPosition;
		} else {
			return null;
		}
	}
	,forEachDirectionFromPoint: function(position,functionToExecute) {
		var left = new common_Point(position.x - 1,position.y);
		if(this.isPositionInWorld(left)) {
			functionToExecute(left);
		}
		var right = new common_Point(position.x + 1,position.y);
		if(this.isPositionInWorld(right)) {
			functionToExecute(right);
		}
		var up = new common_Point(position.x,position.y - 1);
		if(this.isPositionInWorld(up)) {
			functionToExecute(up);
		}
		var down = new common_Point(position.x,position.y + 1);
		if(this.isPositionInWorld(down)) {
			functionToExecute(down);
		}
	}
	,isPositionInWorld: function(position) {
		if(position.x >= 0 && position.y >= 0 && position.x < this.width) {
			return position.y < this.height;
		} else {
			return false;
		}
	}
	,elementsAtPosition: function(position) {
		return this.elementsByPosition[position.x][position.y];
	}
	,noBlockingElementsAt: function(position,viewBlockingOnly) {
		if(viewBlockingOnly == null) {
			viewBlockingOnly = true;
		}
		return !common_ArrayExtensions.any(this.elementsAtPosition(position),function(elem) {
			if(viewBlockingOnly) {
				return elem.get_isViewBlocking();
			} else {
				return elem.get_isBlocking();
			}
		});
	}
	,toWorldPoint: function(point) {
		var newPoint = new common_Point(point.x,point.y);
		newPoint.x -= this.viewX;
		newPoint.y -= 2 + this.viewY;
		if(this.isPositionInWorld(newPoint)) {
			return newPoint;
		} else {
			return null;
		}
	}
	,getQuickExamine: function(position) {
		var help = "";
		var _g = 0;
		var _g1 = this.elementsAtPosition(position);
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			if(element.isCurrentlyVisible) {
				if(help != "") {
					help += "\n";
				}
				help += element.getInfo();
			}
		}
		return help;
	}
	,__class__: World
};
var common_ArrayExtensions = function() { };
common_ArrayExtensions.__name__ = true;
common_ArrayExtensions.any = function(array,fn) {
	var _g = 0;
	while(_g < array.length) {
		var val = array[_g];
		++_g;
		if(fn(val)) {
			return true;
		}
	}
	return false;
};
common_ArrayExtensions.contains = function(array,element) {
	return array.indexOf(element) != -1;
};
var common_Rectangle = function(x,y,width,height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
common_Rectangle.__name__ = true;
common_Rectangle.prototype = {
	__class__: common_Rectangle
};
var common_Point = function(x,y) {
	this.x = x;
	this.y = y;
};
common_Point.__name__ = true;
common_Point.prototype = {
	__class__: common_Point
};
var common_Direction = { __ename__ : true, __constructs__ : ["Left","Right","Up","Down"] };
common_Direction.Left = ["Left",0];
common_Direction.Left.toString = $estr;
common_Direction.Left.__enum__ = common_Direction;
common_Direction.Right = ["Right",1];
common_Direction.Right.toString = $estr;
common_Direction.Right.__enum__ = common_Direction;
common_Direction.Up = ["Up",2];
common_Direction.Up.toString = $estr;
common_Direction.Up.__enum__ = common_Direction;
common_Direction.Down = ["Down",3];
common_Direction.Down.toString = $estr;
common_Direction.Down.__enum__ = common_Direction;
var common_Random = function() { };
common_Random.__name__ = true;
common_Random.getInt = function(val0,val1) {
	var min = 0;
	var max = 2147483647;
	if(val0 != null && val1 != null) {
		min = val0;
		max = val1;
	} else if(val0 != null) {
		max = val0;
	}
	return Math.floor(Math.random() * (max - min)) + min;
};
common_Random.fromArray = function(arr) {
	if(arr.length == 0) {
		throw new js__$Boot_HaxeError("You can't get a random item from an empty array!");
	}
	return arr[common_Random.getInt(arr.length)];
};
var de_polygonal_ds_Hashable = function() { };
de_polygonal_ds_Hashable.__name__ = true;
var de_polygonal_ds_Collection = function() { };
de_polygonal_ds_Collection.__name__ = true;
de_polygonal_ds_Collection.__interfaces__ = [de_polygonal_ds_Hashable];
de_polygonal_ds_Collection.prototype = {
	__class__: de_polygonal_ds_Collection
};
var de_polygonal_ds_Queue = function() { };
de_polygonal_ds_Queue.__name__ = true;
de_polygonal_ds_Queue.__interfaces__ = [de_polygonal_ds_Collection];
var de_polygonal_ds_ArrayedQueue = function(initialCapacity,source,fixed) {
	if(initialCapacity == null) {
		initialCapacity = 16;
	}
	this.mFront = 0;
	this.mSize = 0;
	this.growthRate = -2;
	this.mInitialCapacity = 1 > initialCapacity ? 1 : initialCapacity;
	this.capacity = this.mInitialCapacity;
	if(source != null) {
		this.mSize = source.length;
		var x = this.mSize;
		var y = this.capacity;
		this.capacity = x > y ? x : y;
	}
	var len = this.capacity;
	this.mData = new Array(len);
	if(source != null) {
		var d = this.mData;
		var _g1 = 0;
		var _g = this.mSize;
		while(_g1 < _g) {
			var i = _g1++;
			d[i] = source[i];
		}
	}
	if(fixed) {
		this.growthRate = 0;
	}
};
de_polygonal_ds_ArrayedQueue.__name__ = true;
de_polygonal_ds_ArrayedQueue.__interfaces__ = [de_polygonal_ds_Queue];
de_polygonal_ds_ArrayedQueue.prototype = {
	grow: function() {
		var t = this.capacity;
		this.capacity = de_polygonal_ds_tools_GrowthRate.compute(this.growthRate,this.capacity);
		this.resizeContainer(t,this.capacity);
	}
	,resizeContainer: function(oldSize,newSize) {
		var dst = new Array(newSize);
		if(oldSize < newSize) {
			if(this.mFront + this.mSize > oldSize) {
				var n1 = oldSize - this.mFront;
				var n2 = oldSize - n1;
				de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,n1);
				de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,0,dst,n1,n2);
			} else {
				de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,this.mSize);
			}
		} else if(this.mFront + this.mSize > oldSize) {
			var n11 = oldSize - this.mFront;
			var n21 = this.mSize - this.mFront;
			de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,n11);
			de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,0,dst,this.mFront,n21);
		} else {
			de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,this.mSize);
		}
		this.mData = dst;
		this.mFront = 0;
	}
	,__class__: de_polygonal_ds_ArrayedQueue
};
var de_polygonal_ds_tools_AssertError = function(message,info) {
	if(message == null) {
		message = "";
	}
	this.message = message;
	var stack = haxe_CallStack.toString(haxe_CallStack.callStack());
	var _this_r = new RegExp("\nCalled from de\\.polygonal\\.ds\\.tools\\.AssertError.*$","m".split("u").join(""));
	stack = stack.replace(_this_r,"");
	this.message = "Assertation " + message + " failed in file " + info.fileName + ", line " + info.lineNumber + ", " + info.className + ":: " + info.methodName + "\nCall stack:" + stack;
};
de_polygonal_ds_tools_AssertError.__name__ = true;
de_polygonal_ds_tools_AssertError.prototype = {
	toString: function() {
		return this.message;
	}
	,__class__: de_polygonal_ds_tools_AssertError
};
var de_polygonal_ds_tools_GrowthRate = function() { };
de_polygonal_ds_tools_GrowthRate.__name__ = true;
de_polygonal_ds_tools_GrowthRate.compute = function(rate,capacity) {
	if(true != rate >= -3) {
		throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("invalid growth rate" + " (rate >= -3)",{ fileName : "GrowthRate.hx", lineNumber : 52, className : "de.polygonal.ds.tools.GrowthRate", methodName : "compute"}));
	}
	if(rate > 0) {
		capacity += rate;
	} else {
		switch(rate) {
		case -3:
			capacity <<= 1;
			break;
		case -2:
			capacity = (capacity * 3 >> 1) + 1;
			break;
		case -1:
			var newSize = capacity + 1;
			capacity = (newSize >> 3) + (newSize < 9 ? 3 : 6);
			capacity += newSize;
			break;
		case 0:
			throw new js__$Boot_HaxeError("out of space");
			break;
		}
	}
	return capacity;
};
var de_polygonal_ds_tools_NativeArrayTools = function() { };
de_polygonal_ds_tools_NativeArrayTools.__name__ = true;
de_polygonal_ds_tools_NativeArrayTools.blit = function(src,srcPos,dst,dstPos,n) {
	if(n > 0) {
		if(true != srcPos < src.length) {
			throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("srcPos out of range" + " (srcPos < size(src))",{ fileName : "NativeArrayTools.hx", lineNumber : 187, className : "de.polygonal.ds.tools.NativeArrayTools", methodName : "blit"}));
		}
		if(true != dstPos < dst.length) {
			throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("dstPos out of range" + " (dstPos < size(dst))",{ fileName : "NativeArrayTools.hx", lineNumber : 188, className : "de.polygonal.ds.tools.NativeArrayTools", methodName : "blit"}));
		}
		if(true != (srcPos + n <= src.length && dstPos + n <= dst.length)) {
			throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("n out of range" + " (srcPos + n <= size(src) && dstPos + n <= size(dst))",{ fileName : "NativeArrayTools.hx", lineNumber : 189, className : "de.polygonal.ds.tools.NativeArrayTools", methodName : "blit"}));
		}
		if(src == dst) {
			if(srcPos < dstPos) {
				var i = srcPos + n;
				var j = dstPos + n;
				var _g1 = 0;
				var _g = n;
				while(_g1 < _g) {
					var k = _g1++;
					--i;
					--j;
					src[j] = src[i];
				}
			} else if(srcPos > dstPos) {
				var i1 = srcPos;
				var j1 = dstPos;
				var _g11 = 0;
				var _g2 = n;
				while(_g11 < _g2) {
					var k1 = _g11++;
					src[j1] = src[i1];
					++i1;
					++j1;
				}
			}
		} else if(srcPos == 0 && dstPos == 0) {
			var _g12 = 0;
			var _g3 = n;
			while(_g12 < _g3) {
				var i2 = _g12++;
				dst[i2] = src[i2];
			}
		} else if(srcPos == 0) {
			var _g13 = 0;
			var _g4 = n;
			while(_g13 < _g4) {
				var i3 = _g13++;
				dst[dstPos + i3] = src[i3];
			}
		} else if(dstPos == 0) {
			var _g14 = 0;
			var _g5 = n;
			while(_g14 < _g5) {
				var i4 = _g14++;
				dst[i4] = src[srcPos + i4];
			}
		} else {
			var _g15 = 0;
			var _g6 = n;
			while(_g15 < _g6) {
				var i5 = _g15++;
				dst[dstPos + i5] = src[srcPos + i5];
			}
		}
	}
};
var haxe_StackItem = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"] };
haxe_StackItem.CFunction = ["CFunction",0];
haxe_StackItem.CFunction.toString = $estr;
haxe_StackItem.CFunction.__enum__ = haxe_StackItem;
haxe_StackItem.Module = function(m) { var $x = ["Module",1,m]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.FilePos = function(s,file,line) { var $x = ["FilePos",2,s,file,line]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.Method = function(classname,method) { var $x = ["Method",3,classname,method]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.LocalFunction = function(v) { var $x = ["LocalFunction",4,v]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
var haxe_CallStack = function() { };
haxe_CallStack.__name__ = true;
haxe_CallStack.getStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = function(error,callsites) {
		var stack = [];
		var _g = 0;
		while(_g < callsites.length) {
			var site = callsites[_g];
			++_g;
			if(haxe_CallStack.wrapCallSite != null) {
				site = haxe_CallStack.wrapCallSite(site);
			}
			var method = null;
			var fullName = site.getFunctionName();
			if(fullName != null) {
				var idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					var className = HxOverrides.substr(fullName,0,idx);
					var methodName = HxOverrides.substr(fullName,idx + 1,null);
					method = haxe_StackItem.Method(className,methodName);
				}
			}
			stack.push(haxe_StackItem.FilePos(method,site.getFileName(),site.getLineNumber()));
		}
		return stack;
	};
	var a = haxe_CallStack.makeStack(e.stack);
	Error.prepareStackTrace = oldValue;
	return a;
};
haxe_CallStack.callStack = function() {
	try {
		throw new Error();
	} catch( e ) {
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		var a = haxe_CallStack.getStack(e);
		a.shift();
		return a;
	}
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	while(_g < stack.length) {
		var s = stack[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s[1]) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s[2];
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var line = s[4];
		var file = s[3];
		var s1 = s[2];
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var meth = s[3];
		var cname = s[2];
		b.b += cname == null ? "null" : "" + cname;
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s[2];
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
haxe_CallStack.makeStack = function(s) {
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var rie10 = new EReg("^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$","");
		var _g = 0;
		while(_g < stack.length) {
			var line = stack[_g];
			++_g;
			if(rie10.match(line)) {
				var path = rie10.matched(1).split(".");
				var meth = path.pop();
				var file = rie10.matched(2);
				var line1 = Std.parseInt(rie10.matched(3));
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else {
		return s;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_web_Request = function() { };
haxe_web_Request.__name__ = true;
haxe_web_Request.getParams = function() {
	var get = HxOverrides.substr(window.location.search,1,null);
	var params = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = new EReg("[&;]","g").split(get);
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var pl = p.split("=");
		if(pl.length < 2) {
			continue;
		}
		var name = pl.shift();
		var key = decodeURIComponent(name.split("+").join(" "));
		var s = pl.join("=");
		var value = decodeURIComponent(s.split("+").join(" "));
		if(__map_reserved[key] != null) {
			params.setReserved(key,value);
		} else {
			params.h[key] = value;
		}
	}
	return params;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var ui_InfoDisplay = function(keyboard,world,game,innerFocusable) {
	this.currentLine = 0;
	this.info = "";
	this.innerFocusable = innerFocusable;
	Focusable.call(this,keyboard,world,game);
};
ui_InfoDisplay.__name__ = true;
ui_InfoDisplay.__super__ = Focusable;
ui_InfoDisplay.prototype = $extend(Focusable.prototype,{
	get_showsWorld: function() {
		return this.innerFocusable.get_showsWorld();
	}
	,clear: function() {
		this.info = "";
	}
	,addInfo: function(info) {
		if(this.info != "") {
			this.info += " ";
		}
		this.info += info;
	}
	,processInfo: function(drawer) {
		var addToLast = "...";
		var lines = drawer.splitIntoLines(0,0,this.info,null,null,function(orig,ln) {
			if(ln % 2 == 1) {
				return orig - addToLast.length;
			} else {
				return orig;
			}
		});
		if(lines.length > 2) {
			var _g1 = 0;
			var _g = lines.length - 1;
			while(_g1 < _g) {
				var i = _g1++;
				if(i % 2 == 1) {
					if(lines[i].charAt(lines[i].length - 1) != ".") {
						lines[i] += ".";
					}
					lines[i] += "..";
				}
			}
			this.game.focus(this);
		}
		this.currentLines = lines;
		this.currentLine = 0;
		this.drawCurrentLines(drawer);
	}
	,update: function() {
		if(this.keyboard.anyConfirm()) {
			this.currentLine += 2;
			this.drawCurrentLines(this.game.drawer);
			if(this.currentLine >= this.currentLines.length - 2) {
				this.game.focus(this.innerFocusable,false);
			}
		}
	}
	,drawCurrentLines: function(drawer) {
		drawer.clearLines(0,2);
		if(this.currentLines.length > this.currentLine) {
			drawer.drawText(0,0,this.currentLines[this.currentLine]);
		}
		if(this.currentLines.length > this.currentLine + 1) {
			drawer.drawText(0,1,this.currentLines[this.currentLine + 1]);
		}
	}
	,__class__: ui_InfoDisplay
});
var ui_Menu = function(drawer,keyboard,world,game,innerFocusable,title,items,extraCloseKey) {
	this.scrollTop = 0;
	this.selectedItem = 0;
	this.drawer = drawer;
	Focusable.call(this,keyboard,world,game);
	this.title = title;
	this.items = items;
	this.extraCloseKey = extraCloseKey;
	this.innerFocusable = innerFocusable;
	this.info = new ui_InfoDisplay(keyboard,world,game,this);
	game.focus(this);
	this.draw();
};
ui_Menu.__name__ = true;
ui_Menu.__super__ = Focusable;
ui_Menu.prototype = $extend(Focusable.prototype,{
	close: function() {
		this.game.focus(this.innerFocusable);
	}
	,update: function() {
		if(this.keyboard.anyBack() || this.extraCloseKey != null && this.keyboard.pressed[this.extraCloseKey]) {
			this.close();
		} else {
			var down = this.keyboard.downKey() && !this.keyboard.upKey();
			var up = this.keyboard.upKey() && !this.keyboard.downKey();
			if(down && this.selectedItem < this.items.length - 1) {
				this.selectedItem += 1;
				this.draw();
			} else if(up && this.selectedItem > 0) {
				this.selectedItem -= 1;
				this.draw();
			} else if(this.keyboard.anyConfirm()) {
				if(this.items[this.selectedItem].onUse != null) {
					this.items[this.selectedItem].onUse();
				}
			}
		}
	}
	,draw: function() {
		this.drawer.clear();
		this.drawer.setMultiBackground(0,2,this.title.length,Drawer.colorToInt(Color.DarkGray));
		this.drawer.drawText(0,2,this.title);
		var menuHeight = 0;
		var selectedAt = 0;
		var upperLimit = 3;
		var _g1 = 0;
		var _g = this.items.length;
		while(_g1 < _g) {
			var i = _g1++;
			var item = this.items[i];
			if(this.selectedItem == i) {
				selectedAt = menuHeight;
			}
			menuHeight += item.getHeight(this.drawer);
		}
		var val = selectedAt - ((22 - upperLimit) / 2 | 0);
		var maxVal = menuHeight - 22 + upperLimit;
		this.scrollTop = val < 0 ? 0 : val > maxVal ? maxVal : val;
		var yy = upperLimit - this.scrollTop;
		var _g11 = 0;
		var _g2 = this.items.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var item1 = this.items[i1];
			item1.draw(this.drawer,yy,upperLimit,22,this.selectedItem == i1);
			yy += item1.getHeight(this.drawer);
		}
	}
	,__class__: ui_Menu
});
var ui_MenuItem = function(text,extraDescription,onUse) {
	this.text = text;
	this.extraDescription = extraDescription;
	this.onUse = onUse;
};
ui_MenuItem.__name__ = true;
ui_MenuItem.prototype = {
	getHeight: function(drawer) {
		return 1 + (this.extraDescription == "" ? 0 : drawer.getAmountOfLines(2,0,this.extraDescription));
	}
	,draw: function(drawer,y,minY,maxY,selected) {
		if(y >= maxY) {
			return;
		}
		if(y >= minY) {
			if(selected) {
				drawer.drawText(0,y,">");
			}
			drawer.drawText(2,y,this.text);
		}
		var yy = y + 1;
		if(this.extraDescription != "") {
			var lines = drawer.splitIntoLines(2,y,this.extraDescription);
			var _g = 0;
			while(_g < lines.length) {
				var line = lines[_g];
				++_g;
				if(yy < maxY && yy >= minY) {
					drawer.drawText(2,yy,line,Drawer.colorToInt(Color.LightGray));
				}
				++yy;
			}
		}
	}
	,__class__: ui_MenuItem
};
var worldElements_WorldElement = function(world,position) {
	this.isCurrentlyVisible = false;
	this.seenByPlayer = false;
	this.world = world;
	this.set_position(position);
	this.character = "";
	this.color = Drawer.colorToInt(Color.White);
	this.init();
};
worldElements_WorldElement.__name__ = true;
worldElements_WorldElement.prototype = {
	get_isBlocking: function() {
		return false;
	}
	,get_isViewBlocking: function() {
		return false;
	}
	,get_isEasierVisible: function() {
		return false;
	}
	,set_position: function(newPosition) {
		if(this.position != null) {
			this.world.removeFromElementsAtPosition(this,this.position);
		}
		this.position = newPosition;
		this.world.addToElementsAtPosition(this,newPosition);
		return this.position;
	}
	,init: function() {
	}
	,preUpdate: function() {
	}
	,postUpdate: function() {
	}
	,update: function(isExtra) {
		if(isExtra == null) {
			isExtra = false;
		}
	}
	,draw: function(drawer,notInView) {
		drawer.setWorldCharacter(this.position.x,this.position.y,this.character,this.color,notInView);
	}
	,getInfo: function() {
		return "You don't know what this is!";
	}
	,hasActionFor: function(triggeringWorldElement) {
		return false;
	}
	,performActionFor: function(triggeringWorldElement) {
	}
	,shouldRemove: function() {
		return false;
	}
	,isInterestingForPlayer: function() {
		return false;
	}
	,__class__: worldElements_WorldElement
};
var worldElements_Wall = function(world,position) {
	worldElements_WorldElement.call(this,world,position);
};
worldElements_Wall.__name__ = true;
worldElements_Wall.__super__ = worldElements_WorldElement;
worldElements_Wall.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return true;
	}
	,get_isViewBlocking: function() {
		return true;
	}
	,get_isEasierVisible: function() {
		return true;
	}
	,draw: function(drawer,notInView) {
		drawer.setWorldWall(this.position.x,this.position.y,this.color,notInView);
	}
	,getInfo: function() {
		return "A wall.";
	}
	,__class__: worldElements_Wall
});
var worldElements_creatures_Creature = function(world,position) {
	this.wanderTo = null;
	this.aggresiveToPlayer = false;
	this.followTimeWithoutSee = 3;
	this.lastSeenCreature = new haxe_ds_ObjectMap();
	this.speedPoints = 0;
	this.attackedBy = [];
	this.creatureFullAttackVerb = "bite";
	this.creatureAttackVerb = "bit";
	this.creatureTypeAorAn = "a";
	this.creatureTypeName = "creature";
	this.hasMoved = false;
	worldElements_WorldElement.call(this,world,position);
};
worldElements_creatures_Creature.__name__ = true;
worldElements_creatures_Creature.__super__ = worldElements_WorldElement;
worldElements_creatures_Creature.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return true;
	}
	,init: function() {
		this.movement = new worldElements_creatures_movement_BasicMovement();
		this.stats = new worldElements_creatures_stats_CreatureStats(1,1);
		this.basicAttack = new worldElements_creatures_actions_DirectionalAttack(this);
		this.attackedBy = [];
		this.statusEffects = [];
	}
	,preUpdate: function() {
		this.hasMoved = false;
	}
	,update: function(isExtra) {
		if(isExtra == null) {
			isExtra = false;
		}
		worldElements_WorldElement.prototype.update.call(this);
		if(!this.hasMoved) {
			if(!isExtra) {
				this.speedPoints += this.stats.speed;
			}
			var playerSpeed = this.world.player.controllingBody.stats.speed;
			if(this.speedPoints >= playerSpeed) {
				this.movement.move(this.world,this);
				this.hasMoved = true;
				this.speedPoints -= playerSpeed;
				if(this.speedPoints >= playerSpeed) {
					this.world.requestExtraUpdate(this);
				}
			}
		}
	}
	,postUpdate: function() {
		var i = this.statusEffects.length;
		while(--i >= 0) {
			var statusEffect = this.statusEffects[i];
			statusEffect.onTurn();
			if(statusEffect.ended) {
				this.statusEffects.splice(i,1);
			}
		}
		var creature = this.lastSeenCreature.keys();
		while(creature.hasNext()) {
			var creature1 = creature.next();
			var _g = creature1;
			var _g1 = this.lastSeenCreature;
			var v = _g1.h[_g.__id__] + 1;
			_g1.set(_g,v);
		}
	}
	,getInfo: function() {
		var pre = "";
		var post = "";
		if(this.world.player.ownBody == this && this.world.player.controllingBody == this) {
			pre = "You, ";
		} else if(this.world.player.controllingBody == this) {
			post = ", controlled by you";
		} else if(this.world.player.ownBody == this) {
			pre = "Your own body, ";
		}
		var info = this.stats.getInfo();
		if(this.statusEffects.length > 0) {
			var _g = 0;
			var _g1 = this.statusEffects;
			while(_g < _g1.length) {
				var statusEffect = _g1[_g];
				++_g;
				if(info != "") {
					info += "; ";
				}
				info += statusEffect.name;
			}
		}
		var str = pre + ("" + this.creatureTypeAorAn + " " + this.creatureTypeName + post + " - " + info);
		if(str.length == 0) {
			return str;
		} else {
			return str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null);
		}
	}
	,hasActionFor: function(triggeringWorldElement) {
		if(js_Boot.__instanceof(triggeringWorldElement,worldElements_creatures_Creature)) {
			return true;
		}
		return false;
	}
	,performActionFor: function(triggeringWorldElement) {
		if(js_Boot.__instanceof(triggeringWorldElement,worldElements_creatures_Creature)) {
			triggeringWorldElement.attack(this);
		}
	}
	,attack: function(what) {
		this.basicAttack.useOnElement(what);
	}
	,shouldRemove: function() {
		if(this.stats.hp <= 0) {
			var tmp = this.world.info;
			var str = "" + this.getNameToUse() + " has been defeated.";
			tmp.addInfo(str.length == 0 ? str : str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null));
			return true;
		}
		return false;
	}
	,isInterestingForPlayer: function() {
		if(this.world.player.ownBody != this) {
			return this.world.player.controllingBody == this;
		} else {
			return true;
		}
	}
	,getNameToUse: function() {
		if(this.world.player.ownBody == this || this.world.player.controllingBody == this) {
			return "you";
		} else {
			return "the " + this.creatureTypeName;
		}
	}
	,getReferenceToUse: function(itself) {
		if(itself == null) {
			itself = false;
		}
		if(this.world.player.ownBody == this || this.world.player.controllingBody == this) {
			if(itself) {
				return "yourself";
			} else {
				return "you";
			}
		} else if(itself) {
			return "itself";
		} else {
			return "it";
		}
	}
	,__class__: worldElements_creatures_Creature
});
var worldElements_creatures_Human = function(world,position) {
	worldElements_creatures_Creature.call(this,world,position);
};
worldElements_creatures_Human.__name__ = true;
worldElements_creatures_Human.__super__ = worldElements_creatures_Creature;
worldElements_creatures_Human.prototype = $extend(worldElements_creatures_Creature.prototype,{
	init: function() {
		worldElements_creatures_Creature.prototype.init.call(this);
		this.color = Drawer.colorToInt(Color.LightBlue);
		this.character = "@";
		this.creatureTypeName = "human";
		this.stats.setMaxHP(10);
		this.stats.setMaxAP(10);
		this.stats.setAttack(3);
		this.creatureAttackVerb = "hit";
		this.creatureFullAttackVerb = "hit";
	}
	,__class__: worldElements_creatures_Human
});
var worldElements_creatures_Rat = function(world,position) {
	worldElements_creatures_Creature.call(this,world,position);
};
worldElements_creatures_Rat.__name__ = true;
worldElements_creatures_Rat.__super__ = worldElements_creatures_Creature;
worldElements_creatures_Rat.prototype = $extend(worldElements_creatures_Creature.prototype,{
	init: function() {
		worldElements_creatures_Creature.prototype.init.call(this);
		this.color = 14259306;
		this.character = "r";
		this.creatureTypeName = "rat";
		this.stats.setMaxHP(5);
		this.stats.setMaxAP(1);
		this.stats.setAttack(1);
		this.stats.speed = 150;
	}
	,__class__: worldElements_creatures_Rat
});
var worldElements_creatures_actions_AttackResult = { __ename__ : true, __constructs__ : ["Damage","Block"] };
worldElements_creatures_actions_AttackResult.Damage = function(damage) { var $x = ["Damage",0,damage]; $x.__enum__ = worldElements_creatures_actions_AttackResult; $x.toString = $estr; return $x; };
worldElements_creatures_actions_AttackResult.Block = ["Block",1];
worldElements_creatures_actions_AttackResult.Block.toString = $estr;
worldElements_creatures_actions_AttackResult.Block.__enum__ = worldElements_creatures_actions_AttackResult;
var worldElements_creatures_actions_AttackCalculator = function() { };
worldElements_creatures_actions_AttackCalculator.__name__ = true;
worldElements_creatures_actions_AttackCalculator.basicAttack = function(attackingCreature,attackedCreature) {
	var attackPart = attackingCreature.stats.attack;
	var defencePart = attackedCreature.stats.defence;
	var damage = attackPart - defencePart;
	attackedCreature.stats.hp -= damage;
	var result;
	if(damage > 0) {
		result = worldElements_creatures_actions_AttackResult.Damage(damage);
	} else if(defencePart > 0) {
		result = worldElements_creatures_actions_AttackResult.Block;
	} else {
		result = worldElements_creatures_actions_AttackResult.Damage(0);
	}
	worldElements_creatures_actions_AttackCalculator.attackStandardResults(attackingCreature,attackedCreature);
	return result;
};
worldElements_creatures_actions_AttackCalculator.attackStandardResults = function(attackingCreature,attackedCreature) {
	if(!common_ArrayExtensions.contains(attackedCreature.attackedBy,attackingCreature)) {
		attackedCreature.attackedBy.push(attackingCreature);
	}
};
var worldElements_creatures_actions_CreatureAction = function(creature) {
	this.creature = creature;
};
worldElements_creatures_actions_CreatureAction.__name__ = true;
worldElements_creatures_actions_CreatureAction.prototype = {
	__class__: worldElements_creatures_actions_CreatureAction
};
var worldElements_creatures_actions_DirectionAction = function(creature) {
	worldElements_creatures_actions_CreatureAction.call(this,creature);
};
worldElements_creatures_actions_DirectionAction.__name__ = true;
worldElements_creatures_actions_DirectionAction.__super__ = worldElements_creatures_actions_CreatureAction;
worldElements_creatures_actions_DirectionAction.prototype = $extend(worldElements_creatures_actions_CreatureAction.prototype,{
	__class__: worldElements_creatures_actions_DirectionAction
});
var worldElements_creatures_actions_DirectionalAttack = function(creature) {
	worldElements_creatures_actions_DirectionAction.call(this,creature);
};
worldElements_creatures_actions_DirectionalAttack.__name__ = true;
worldElements_creatures_actions_DirectionalAttack.__super__ = worldElements_creatures_actions_DirectionAction;
worldElements_creatures_actions_DirectionalAttack.prototype = $extend(worldElements_creatures_actions_DirectionAction.prototype,{
	useOnElement: function(elementHere) {
		var creatureHere = elementHere;
		var result = worldElements_creatures_actions_AttackCalculator.basicAttack(this.creature,creatureHere);
		if(this.creature.isInterestingForPlayer() || elementHere.isInterestingForPlayer()) {
			var text;
			switch(result[1]) {
			case 0:
				var damage = result[2];
				var str = "" + this.creature.getNameToUse() + " " + this.creature.creatureAttackVerb + " " + creatureHere.getNameToUse() + " for " + damage + " damage.";
				if(str.length == 0) {
					text = str;
				} else {
					text = str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null);
				}
				break;
			case 1:
				var str1 = "" + this.creature.getNameToUse() + " tried to " + this.creature.creatureFullAttackVerb + " " + creatureHere.getNameToUse() + ", but " + creatureHere.getReferenceToUse() + " defended " + creatureHere.getReferenceToUse(true) + ".";
				if(str1.length == 0) {
					text = str1;
				} else {
					text = str1.charAt(0).toUpperCase() + HxOverrides.substr(str1,1,null);
				}
				break;
			}
			this.creature.world.info.addInfo(text);
		}
	}
	,__class__: worldElements_creatures_actions_DirectionalAttack
});
var worldElements_creatures_movement_Movement = function() { };
worldElements_creatures_movement_Movement.__name__ = true;
worldElements_creatures_movement_Movement.prototype = {
	canMove: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			var elementsHere = world.elementsAtPosition(newPosition);
			if(!this.isBlockingElementIn(world,elementsHere)) {
				return true;
			}
			if(common_ArrayExtensions.any(elementsHere,function(e) {
				return e.hasActionFor(creature);
			})) {
				return true;
			}
		}
		return false;
	}
	,isBlockingElementIn: function(world,elementsHere) {
		if(!common_ArrayExtensions.any(elementsHere,function(e) {
			return e.get_isBlocking();
		})) {
			return false;
		}
		return true;
	}
	,move: function(world,creature) {
	}
	,moveInDirection: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			var elementsHere = world.elementsAtPosition(newPosition);
			if(!this.isBlockingElementIn(world,elementsHere)) {
				creature.set_position(newPosition);
			}
			var _g = 0;
			while(_g < elementsHere.length) {
				var elem = elementsHere[_g];
				++_g;
				if(elem != creature && elem.hasActionFor(creature)) {
					elem.performActionFor(creature);
					break;
				}
			}
		}
	}
	,__class__: worldElements_creatures_movement_Movement
};
var worldElements_creatures_movement_BasicMovement = function() {
};
worldElements_creatures_movement_BasicMovement.__name__ = true;
worldElements_creatures_movement_BasicMovement.__super__ = worldElements_creatures_movement_Movement;
worldElements_creatures_movement_BasicMovement.prototype = $extend(worldElements_creatures_movement_Movement.prototype,{
	move: function(world,creature) {
		var aggresiveToCreatures = creature.attackedBy.slice();
		if(creature.aggresiveToPlayer && !common_ArrayExtensions.contains(aggresiveToCreatures,world.player.ownBody)) {
			aggresiveToCreatures.push(world.player.ownBody);
		}
		var isAggresiveToThis = function(elem) {
			if(js_Boot.__instanceof(elem,worldElements_creatures_Creature)) {
				return common_ArrayExtensions.contains(aggresiveToCreatures,elem);
			} else {
				return false;
			}
		};
		var toTargets = world.pathfinder.find(creature.position,function(pos) {
			return common_ArrayExtensions.any(world.elementsAtPosition(pos),isAggresiveToThis);
		},true);
		var nearestTarget = null;
		var nearestTargetInfo = null;
		var nearestTargetDistance = 1000000;
		var _g = 0;
		while(_g < toTargets.length) {
			var toTarget = toTargets[_g];
			++_g;
			var target = world.elementsAtPosition(toTarget.point).filter(isAggresiveToThis)[0];
			var canSee = world.pathfinder.isVisible(creature.position,target.position);
			if(canSee) {
				creature.lastSeenCreature.set(target,0);
			}
			if(creature.lastSeenCreature.h[target.__id__] <= creature.followTimeWithoutSee) {
				nearestTarget = target;
				nearestTargetInfo = toTarget;
				nearestTargetDistance = toTarget.distance;
			}
		}
		if(nearestTarget != null) {
			if(nearestTargetInfo.distance == 1) {
				creature.attack(nearestTarget);
			} else {
				this.moveInDirection(world,creature,nearestTargetInfo.inDirection);
			}
		} else {
			if(creature.wanderTo == null) {
				var wanderToOptions = world.pathfinder.find(creature.position,function(p) {
					return world.noBlockingElementsAt(p);
				},true);
				if(wanderToOptions.length > 0) {
					creature.wanderTo = common_Random.fromArray(wanderToOptions).point;
				}
			}
			console.log(creature.wanderTo);
			if(creature.wanderTo != null) {
				var wanderInfo = world.pathfinder.find(creature.position,function(p1) {
					var otherPoint = creature.wanderTo;
					if(p1.x == otherPoint.x) {
						return p1.y == otherPoint.y;
					} else {
						return false;
					}
				},false);
				if(wanderInfo.length > 0) {
					this.moveInDirection(world,creature,wanderInfo[0].inDirection);
					if(creature.position == creature.wanderTo) {
						creature.wanderTo = null;
					}
				} else {
					creature.wanderTo = null;
				}
			}
		}
	}
	,__class__: worldElements_creatures_movement_BasicMovement
});
var worldElements_creatures_stats_CreatureStats = function(hp,ap,attack,defence) {
	if(defence == null) {
		defence = 0;
	}
	if(attack == null) {
		attack = 0;
	}
	this.maxHP = hp;
	this.maxAP = ap;
	this.attack = attack;
	this.defence = defence;
	this.hp = hp;
	this.ap = ap;
	this.speed = 100;
};
worldElements_creatures_stats_CreatureStats.__name__ = true;
worldElements_creatures_stats_CreatureStats.prototype = {
	getInfo: function() {
		return "HP: " + this.hp + "/" + this.maxHP + "; AP: " + this.ap + "/" + this.maxAP;
	}
	,setMaxHP: function(newMaxHP) {
		var diff = newMaxHP - this.maxHP;
		this.maxHP = newMaxHP;
		this.hp += diff;
	}
	,setMaxAP: function(newMaxAP) {
		var diff = newMaxAP - this.maxAP;
		this.maxAP = newMaxAP;
		this.ap += diff;
	}
	,setAttack: function(attack) {
		this.attack = attack;
	}
	,__class__: worldElements_creatures_stats_CreatureStats
};
var worldElements_creatures_statusEffects_StatusEffect = function() {
	this.ended = false;
	this.name = "";
};
worldElements_creatures_statusEffects_StatusEffect.__name__ = true;
worldElements_creatures_statusEffects_StatusEffect.prototype = {
	onTurn: function() {
	}
	,getText: function() {
		return "";
	}
	,__class__: worldElements_creatures_statusEffects_StatusEffect
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {};
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=game_js.js.map