// Generated by Haxe 3.4.4
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Color = { __ename__ : true, __constructs__ : ["Red","Green","Blue","Black","White","Gray","LightBlue","Purple","Yellow","DarkGray","LightGray","DarkLightBlue"] };
Color.Red = ["Red",0];
Color.Red.toString = $estr;
Color.Red.__enum__ = Color;
Color.Green = ["Green",1];
Color.Green.toString = $estr;
Color.Green.__enum__ = Color;
Color.Blue = ["Blue",2];
Color.Blue.toString = $estr;
Color.Blue.__enum__ = Color;
Color.Black = ["Black",3];
Color.Black.toString = $estr;
Color.Black.__enum__ = Color;
Color.White = ["White",4];
Color.White.toString = $estr;
Color.White.__enum__ = Color;
Color.Gray = ["Gray",5];
Color.Gray.toString = $estr;
Color.Gray.__enum__ = Color;
Color.LightBlue = ["LightBlue",6];
Color.LightBlue.toString = $estr;
Color.LightBlue.__enum__ = Color;
Color.Purple = ["Purple",7];
Color.Purple.toString = $estr;
Color.Purple.__enum__ = Color;
Color.Yellow = ["Yellow",8];
Color.Yellow.toString = $estr;
Color.Yellow.__enum__ = Color;
Color.DarkGray = ["DarkGray",9];
Color.DarkGray.toString = $estr;
Color.DarkGray.__enum__ = Color;
Color.LightGray = ["LightGray",10];
Color.LightGray.toString = $estr;
Color.LightGray.__enum__ = Color;
Color.DarkLightBlue = ["DarkLightBlue",11];
Color.DarkLightBlue.toString = $estr;
Color.DarkLightBlue.__enum__ = Color;
var Drawer = function(stage) {
	this.stage = stage;
	this.wallGraphics = new PIXI.Graphics();
	stage.addChild(this.wallGraphics);
	this.bitmaps = [];
	var _g = 0;
	while(_g < 24) {
		var i = _g++;
		this.bitmaps[i] = [];
		var _g1 = 0;
		while(_g1 < 50) {
			var j = _g1++;
			var bitmap = new PIXI.extras.BitmapText("",{ font : "font", tint : 16777215});
			this.bitmaps[i][j] = bitmap;
			bitmap.position.set(j * 15,i * 25 - 5);
			stage.addChild(bitmap);
		}
	}
};
Drawer.__name__ = true;
Drawer.colorToInt = function(color) {
	switch(color[1]) {
	case 0:
		return 16711680;
	case 1:
		return 65280;
	case 2:
		return 255;
	case 3:
		return 0;
	case 4:
		return 16777215;
	case 5:
		return 8421504;
	case 6:
		return 4376052;
	case 7:
		return 9060294;
	case 8:
		return 16776960;
	case 9:
		return 4210752;
	case 10:
		return 11579568;
	case 11:
		return 2191490;
	}
};
Drawer.prototype = {
	clear: function() {
		this.clearLines(0,24);
		this.wallGraphics.clear();
	}
	,destroy: function() {
		var _g = 0;
		while(_g < 24) {
			var i = _g++;
			var _g1 = 0;
			while(_g1 < 50) {
				var j = _g1++;
				this.stage.removeChild(this.bitmaps[i][j]);
			}
		}
		this.stage.removeChild(this.wallGraphics);
	}
	,clearLines: function(start,amount) {
		var _g1 = start;
		var _g = start + amount;
		while(_g1 < _g) {
			var i = _g1++;
			var _g2 = 0;
			while(_g2 < 50) {
				var j = _g2++;
				this.bitmaps[i][j].text = "";
			}
		}
	}
	,setMouseHelp: function(text) {
		this.clearLines(22,2);
		var yy = 22;
		if(this.getAmountOfLines(0,22,"Examine: " + text) == 1) {
			++yy;
		}
		var col = 0;
		if(text != "") {
			col = Drawer.colorToInt(Color.DarkGray);
		}
		this.setMultiBackground(0,yy,"Examine:".length,col);
		this.setMultiBackground(0,yy == 22 ? 23 : 22,"Examine:".length,0);
		if(text != "") {
			this.drawText(0,yy,"Examine: " + text);
		}
	}
	,setMultiBackground: function(x,y,width,col) {
		var _g1 = x;
		var _g = x + width;
		while(_g1 < _g) {
			var i = _g1++;
			this.setBackground(i,y,col);
		}
	}
	,setWorldView: function(screenX,screenY,worldX,worldY,width,height) {
		this.screenX = screenX;
		this.screenY = screenY;
		this.worldX = worldX;
		this.worldY = worldY;
		this.worldWidth = width;
		this.worldHeight = height;
	}
	,setWorldCharacter: function(x,y,character,color,notInView) {
		if(notInView == null) {
			notInView = false;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x >= this.worldX && y >= this.worldY && x < this.worldX + this.worldWidth && y < this.worldY + this.worldHeight) {
			this.setCharacter(x - this.worldX + this.screenX,y - this.worldY + this.screenY,character,color,notInView ? 0.5 : 1);
		}
	}
	,setWorldWall: function(x,y,color,notInView) {
		if(notInView == null) {
			notInView = false;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x >= this.worldX && y >= this.worldY && x < this.worldX + this.worldWidth && y < this.worldY + this.worldHeight) {
			this.setBackground(x - this.worldX + this.screenX,y - this.worldY + this.screenY,color,notInView ? 0.5 : 1);
		}
	}
	,setCharacter: function(x,y,character,color,alpha) {
		if(alpha == null) {
			alpha = 1.0;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x < 0 || y < 0 || x >= 50 || y >= 24) {
			return;
		}
		this.bitmaps[y][x].text = character;
		this.bitmaps[y][x].tint = color;
		this.bitmaps[y][x].alpha = alpha;
	}
	,setBackground: function(x,y,color,alpha) {
		if(alpha == null) {
			alpha = 1.0;
		}
		if(color == null) {
			color = 16777215;
		}
		if(x < 0 || y < 0 || x >= 50 || y >= 24) {
			return;
		}
		this.wallGraphics.beginFill(color,alpha);
		this.wallGraphics.drawRect(x * 15,y * 25,15,25);
		this.wallGraphics.endFill();
	}
	,drawText: function(x,y,text,color,wrap,maxWidth,getMaxX) {
		if(maxWidth == null) {
			maxWidth = -1;
		}
		if(wrap == null) {
			wrap = true;
		}
		if(color == null) {
			color = 16777215;
		}
		var lines = this.splitIntoLines(x,y,text,wrap,maxWidth,getMaxX);
		var minX = x;
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			var _g2 = 0;
			var _g1 = line.length;
			while(_g2 < _g1) {
				var i = _g2++;
				this.setCharacter(x,y,line.charAt(i),color);
				++x;
			}
			++y;
			x = minX;
		}
		return lines.length;
	}
	,splitIntoLines: function(x,y,text,wrap,maxWidth,getMaxX) {
		if(maxWidth == null) {
			maxWidth = -1;
		}
		if(wrap == null) {
			wrap = true;
		}
		var minX = x;
		var maxX;
		if(maxWidth == -1) {
			maxX = 50;
		} else {
			var val2 = x + maxWidth;
			if(val2 < 50) {
				maxX = val2;
			} else {
				maxX = 50;
			}
		}
		if(getMaxX == null) {
			getMaxX = function(i,j) {
				return i;
			};
		}
		var lines = text.split("\n");
		var finalLines = [];
		var finalLine = "";
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			var words = line.split(" ");
			var _g1 = 0;
			while(_g1 < words.length) {
				var word = words[_g1];
				++_g1;
				if(x + word.length >= getMaxX(maxX,finalLines.length)) {
					finalLines.push(finalLine);
					finalLine = "";
					x = minX;
					++y;
				}
				if(finalLine != "") {
					finalLine += " ";
				}
				finalLine += word;
				x += word.length + 1;
			}
			finalLines.push(finalLine);
			finalLine = "";
			++y;
			x = minX;
		}
		return finalLines;
	}
	,getAmountOfLines: function(x,y,text,wrap,maxWidth,getMaxX) {
		if(maxWidth == null) {
			maxWidth = -1;
		}
		if(wrap == null) {
			wrap = true;
		}
		return this.splitIntoLines(x,y,text,wrap,maxWidth,getMaxX).length;
	}
	,__class__: Drawer
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,__class__: EReg
};
var Focusable = function(keyboard,world,game) {
	this.keyboard = keyboard;
	this.world = world;
	this.game = game;
};
Focusable.__name__ = true;
Focusable.prototype = {
	get_showsWorld: function() {
		return false;
	}
	,update: function() {
	}
	,draw: function() {
	}
	,__class__: Focusable
};
var Game = function(application,stage,gameRect) {
	this.application = application;
	this.stage = stage;
	this.rect = gameRect;
	this.drawer = new Drawer(stage);
	this.keyboard = new Keyboard();
	this.world = new World(this.drawer);
	this.mouse = new Mouse(stage,this.world);
	this.player = new Player(this.keyboard,this.world,this);
	this.world.player = this.player;
	this.focusedElement = this.player;
	this.info = new ui_InfoDisplay(this.keyboard,this.world,this,this.player);
	this.world.info = this.info;
	this.world.generateLevel();
	this.drawWorld();
};
Game.__name__ = true;
Game.prototype = {
	restartGame: function() {
		this.drawer.destroy();
		this.application.startGame();
	}
	,update: function(timeMod) {
		this.keyboard.update();
		this.focusedElement.update();
		this.postUpdate();
	}
	,focus: function(element,redrawIfWorld) {
		if(redrawIfWorld == null) {
			redrawIfWorld = true;
		}
		this.focusedElement = element;
		if(element.get_showsWorld() && redrawIfWorld) {
			this.drawWorld();
		}
		this.focusedElement.draw();
	}
	,drawWorld: function() {
		this.drawer.clear();
		this.world.draw();
	}
	,postUpdate: function() {
		this.keyboard.postUpdate();
		if(this.focusedElement.get_showsWorld()) {
			var mouseWorldPos = this.world.toWorldPoint(this.mouse.mousePosition);
			if(mouseWorldPos != null) {
				this.drawer.setMouseHelp(this.world.getQuickExamine(mouseWorldPos));
			} else {
				this.drawer.setMouseHelp("");
			}
		}
	}
	,beforeStep: function() {
		this.drawer.clear();
		this.info.clear();
		this.world.preUpdate();
	}
	,afterStep: function() {
		this.world.update();
		this.info.processInfo(this.drawer);
	}
	,__class__: Game
};
var GameLoader = function(then) {
	this.loader = new PIXI.loaders.Loader();
	this.loader.add("fonts/font-export.fnt");
	this.loader["use"](function(res,next) {
		next();
	});
	this.loader.load(then);
};
GameLoader.__name__ = true;
GameLoader.prototype = {
	update: function() {
		console.log(this.loader.progress + "% loaded");
	}
	,__class__: GameLoader
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Keyboard = function() {
	var _gthis = this;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var i = _g1++;
		_g.push(false);
	}
	this.pressed = _g;
	var _g11 = [];
	var _g2 = 0;
	while(_g2 < 256) {
		var i1 = _g2++;
		_g11.push(false);
	}
	this.down = _g11;
	window.addEventListener("keydown",function(event) {
		var keyCode = event.keyCode;
		if(keyCode < 256) {
			_gthis.pressed[keyCode] = true;
			_gthis.down[keyCode] = true;
		}
	},false);
	window.addEventListener("keyup",function(event1) {
		var keyCode1 = event1.keyCode;
		if(keyCode1 < 256) {
			_gthis.down[keyCode1] = false;
		}
	},false);
};
Keyboard.__name__ = true;
Keyboard.getLetterCode = function(letter) {
	var code = HxOverrides.cca(letter,0);
	if(code >= 97 && code <= 122) {
		code -= 32;
	}
	return code;
};
Keyboard.prototype = {
	anyConfirm: function() {
		if(!this.pressed[32]) {
			return this.pressed[13];
		} else {
			return true;
		}
	}
	,anyBack: function() {
		if(!this.pressed[27]) {
			return this.pressed[8];
		} else {
			return true;
		}
	}
	,update: function() {
	}
	,postUpdate: function() {
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			this.pressed[i] = false;
		}
	}
	,leftKey: function() {
		if(!this.pressed[37]) {
			return this.pressed[Keyboard.getLetterCode("A")];
		} else {
			return true;
		}
	}
	,rightKey: function() {
		if(!this.pressed[39]) {
			return this.pressed[Keyboard.getLetterCode("D")];
		} else {
			return true;
		}
	}
	,upKey: function() {
		if(!this.pressed[38]) {
			return this.pressed[Keyboard.getLetterCode("W")];
		} else {
			return true;
		}
	}
	,downKey: function() {
		if(!this.pressed[40]) {
			return this.pressed[Keyboard.getLetterCode("S")];
		} else {
			return true;
		}
	}
	,__class__: Keyboard
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.find = function(it,f) {
	var v = $iterator(it)();
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
var pixi_plugins_app_Application = function() {
	this._animationFrameId = null;
	this.pixelRatio = 1;
	this.autoResize = true;
	this.transparent = false;
	this.antialias = false;
	this.forceFXAA = false;
	this.roundPixels = false;
	this.legacy = false;
	this.clearBeforeRender = true;
	this.preserveDrawingBuffer = false;
	this.backgroundColor = 16777215;
	this.width = window.innerWidth;
	this.height = window.innerHeight;
	this.position = "static";
};
pixi_plugins_app_Application.__name__ = true;
pixi_plugins_app_Application.prototype = {
	start: function(rendererType,parentDom,canvasElement) {
		if(rendererType == null) {
			rendererType = "auto";
		}
		if(canvasElement == null) {
			this.canvas = window.document.createElement("canvas");
			this.canvas.style.width = this.width + "px";
			this.canvas.style.height = this.height + "px";
			this.canvas.style.position = this.position;
		} else {
			this.canvas = canvasElement;
		}
		if(this.autoResize) {
			window.onresize = $bind(this,this._onWindowResize);
		}
		var renderingOptions = { };
		renderingOptions.width = this.width | 0;
		renderingOptions.height = this.height | 0;
		renderingOptions.view = this.canvas;
		renderingOptions.backgroundColor = this.backgroundColor;
		renderingOptions.resolution = this.pixelRatio;
		renderingOptions.antialias = this.antialias;
		renderingOptions.forceFXAA = this.forceFXAA;
		renderingOptions.autoResize = this.autoResize;
		renderingOptions.transparent = this.transparent;
		renderingOptions.clearBeforeRender = this.clearBeforeRender;
		renderingOptions.preserveDrawingBuffer = this.preserveDrawingBuffer;
		renderingOptions.roundPixels = this.roundPixels;
		renderingOptions.legacy = this.legacy;
		if(rendererType == null) {
			this.app = new PIXI.Application(renderingOptions);
		} else if(rendererType == "canvas") {
			renderingOptions.forceCanvas = true;
			this.app = new PIXI.Application(renderingOptions);
		} else {
			this.app = new PIXI.Application(renderingOptions);
		}
		this.stage = this.app.stage;
		this.renderer = this.app.renderer;
		if(parentDom == null) {
			window.document.body.appendChild(this.app.view);
		} else {
			parentDom.appendChild(this.app.view);
		}
		this.app.ticker.add($bind(this,this._onRequestAnimationFrame));
	}
	,_onWindowResize: function(event) {
		this.width = window.innerWidth;
		this.height = window.innerHeight;
		this.app.renderer.resize(this.width,this.height);
		this.canvas.style.width = this.width + "px";
		this.canvas.style.height = this.height + "px";
		if(this.onResize != null) {
			this.onResize();
		}
	}
	,_onRequestAnimationFrame: function() {
		if(this.onUpdate != null) {
			this.onUpdate(this.app.ticker.deltaTime);
		}
	}
	,__class__: pixi_plugins_app_Application
};
var Main = function() {
	pixi_plugins_app_Application.call(this);
	this.init();
};
Main.__name__ = true;
Main.main = function() {
	new Main();
};
Main.__super__ = pixi_plugins_app_Application;
Main.prototype = $extend(pixi_plugins_app_Application.prototype,{
	init: function() {
		var _gthis = this;
		this.autoResize = false;
		this.onUpdate = $bind(this,this.update);
		this.backgroundColor = 0;
		this.clearBeforeRender = true;
		this.width = 750;
		this.height = 600;
		this.initConfig();
		pixi_plugins_app_Application.prototype.start.call(this);
		this.gameRect = new common_Rectangle(0,0,750,600);
		this.loader = new GameLoader(function() {
			console.log("loaded");
			_gthis.loader = null;
			_gthis.startGame();
		});
		this.canvas.addEventListener("contextmenu",function(ev) {
			ev.preventDefault();
			return false;
		});
	}
	,startGame: function() {
		this.game = new Game(this,this.stage,this.gameRect);
	}
	,initConfig: function() {
		try {
			var params = haxe_web_Request.getParams();
		} catch( e ) {
		}
	}
	,update: function(elapsedTime) {
		if(this.game != null) {
			this.game.update(elapsedTime);
		} else if(this.loader != null) {
			this.loader.update();
		}
	}
	,__class__: Main
});
Math.__name__ = true;
var Mouse = function(stage,world) {
	this.mousePosition = new common_Point(-1,-1);
	this.mouseRawPosition = new common_Point(-1,-1);
	var _gthis = this;
	stage.interactive = true;
	stage.on("pointermove",function(e) {
		var point = e.data.getLocalPosition(stage);
		var tmp = new common_Point(Math.floor(point.x),Math.floor(point.y));
		_gthis.mouseRawPosition = tmp;
		_gthis.mousePosition = new common_Point(_gthis.mouseRawPosition.x / 15 | 0,_gthis.mouseRawPosition.y / 25 | 0);
	});
};
Mouse.__name__ = true;
Mouse.prototype = {
	__class__: Mouse
};
var Pathfinder = function(world) {
	this.world = world;
};
Pathfinder.__name__ = true;
Pathfinder.prototype = {
	find: function(fromPosition,isGoal,all) {
		if(all == null) {
			all = true;
		}
		var _g = [];
		var _g2 = 0;
		var _g1 = this.world.width;
		while(_g2 < _g1) {
			var i = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.world.height;
			while(_g5 < _g4) {
				var j = _g5++;
				_g3.push(false);
			}
			_g.push(_g3);
		}
		var visited = _g;
		var queue = new de_polygonal_ds_ArrayedQueue();
		var firstDirection = new haxe_ds_ObjectMap();
		var totalDistance = new haxe_ds_ObjectMap();
		var foundPositions = [];
		if(queue.capacity == queue.mSize) {
			queue.grow();
		}
		queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = fromPosition;
		visited[fromPosition.x][fromPosition.y] = true;
		firstDirection.set(fromPosition,null);
		totalDistance.set(fromPosition,0);
		while(queue.mSize != 0) {
			if(true != queue.mSize > 0) {
				throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("queue is empty" + " (size > 0)",{ fileName : "ArrayedQueue.hx", lineNumber : 166, className : "de.polygonal.ds.ArrayedQueue", methodName : "dequeue"}));
			}
			var x = queue.mData[queue.mFront++];
			if(queue.mFront == queue.capacity) {
				queue.mFront = 0;
			}
			queue.mSize--;
			var queueItem = x;
			var firstDir = firstDirection.h[queueItem.__id__];
			var thisDistance = totalDistance.h[queueItem.__id__];
			if(queueItem != fromPosition && isGoal(queueItem)) {
				foundPositions.push({ point : queueItem, inDirection : firstDir, distance : thisDistance});
				if(!all) {
					break;
				}
			}
			if(queueItem == fromPosition || !common_ArrayExtensions.any(this.world.elementsAtPosition(queueItem),function(elem) {
				return elem.get_isBlocking();
			})) {
				if(queueItem.x > 0 && !visited[queueItem.x - 1][queueItem.y]) {
					visited[queueItem.x - 1][queueItem.y] = true;
					var newPoint = new common_Point(queueItem.x - 1,queueItem.y);
					var v = firstDir == null ? common_Direction.Left : firstDir;
					firstDirection.set(newPoint,v);
					var v1 = thisDistance + 1;
					totalDistance.set(newPoint,v1);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint;
				}
				if(queueItem.y > 0 && !visited[queueItem.x][queueItem.y - 1]) {
					visited[queueItem.x][queueItem.y - 1] = true;
					var newPoint1 = new common_Point(queueItem.x,queueItem.y - 1);
					var v2 = firstDir == null ? common_Direction.Up : firstDir;
					firstDirection.set(newPoint1,v2);
					var v3 = thisDistance + 1;
					totalDistance.set(newPoint1,v3);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint1;
				}
				if(queueItem.x < this.world.width - 1 && !visited[queueItem.x + 1][queueItem.y]) {
					visited[queueItem.x + 1][queueItem.y] = true;
					var newPoint2 = new common_Point(queueItem.x + 1,queueItem.y);
					var v4 = firstDir == null ? common_Direction.Right : firstDir;
					firstDirection.set(newPoint2,v4);
					var v5 = thisDistance + 1;
					totalDistance.set(newPoint2,v5);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint2;
				}
				if(queueItem.y < this.world.height - 1 && !visited[queueItem.x][queueItem.y + 1]) {
					visited[queueItem.x][queueItem.y + 1] = true;
					var newPoint3 = new common_Point(queueItem.x,queueItem.y + 1);
					var v6 = firstDir == null ? common_Direction.Down : firstDir;
					firstDirection.set(newPoint3,v6);
					var v7 = thisDistance + 1;
					totalDistance.set(newPoint3,v7);
					if(queue.capacity == queue.mSize) {
						queue.grow();
					}
					queue.mData[(queue.mSize++ + queue.mFront) % queue.capacity] = newPoint3;
				}
			}
		}
		return foundPositions;
	}
	,isVisible: function(firstPosition,secondPosition,onlyViewBlocking,cornersAreBlocking) {
		if(cornersAreBlocking == null) {
			cornersAreBlocking = true;
		}
		if(onlyViewBlocking == null) {
			onlyViewBlocking = true;
		}
		var _gthis = this;
		var checkIfBlocking = function(elem) {
			if(onlyViewBlocking) {
				return elem.get_isViewBlocking();
			} else {
				return elem.get_isBlocking();
			}
		};
		var checkPoint = function(y,x) {
			if(firstPosition.x == x && firstPosition.y == y || secondPosition.x == x && secondPosition.y == y) {
				return false;
			}
			return common_ArrayExtensions.any(_gthis.world.elementsAtPosition(new common_Point(x,y)),checkIfBlocking);
		};
		var x1 = firstPosition.x;
		var y1 = firstPosition.y;
		var x2 = secondPosition.x;
		var y2 = secondPosition.y;
		var i;
		var ystep;
		var xstep;
		var error;
		var errorprev;
		var y3 = y1;
		var x3 = x1;
		var ddy;
		var ddx;
		var dx = x2 - x1;
		var dy = y2 - y1;
		if(checkPoint(y1,x1)) {
			return false;
		}
		if(dy < 0) {
			ystep = -1;
			dy = -dy;
		} else {
			ystep = 1;
		}
		if(dx < 0) {
			xstep = -1;
			dx = -dx;
		} else {
			xstep = 1;
		}
		ddy = 2 * dy;
		ddx = 2 * dx;
		if(ddx >= ddy) {
			error = dx;
			errorprev = error;
			var _g1 = 0;
			var _g = dx;
			while(_g1 < _g) {
				var i1 = _g1++;
				x3 += xstep;
				error += ddy;
				if(error > ddx) {
					y3 += ystep;
					error -= ddx;
					if(error + errorprev < ddx) {
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
					} else if(error + errorprev > ddx) {
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
					} else if(cornersAreBlocking) {
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
					}
				}
				if(checkPoint(y3,x3)) {
					return false;
				}
				errorprev = error;
			}
		} else {
			error = dy;
			errorprev = error;
			var _g11 = 0;
			var _g2 = dy;
			while(_g11 < _g2) {
				var i2 = _g11++;
				y3 += ystep;
				error += ddx;
				if(error > ddy) {
					x3 += xstep;
					error -= ddy;
					if(error + errorprev < ddy) {
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
					} else if(error + errorprev > ddy) {
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
					} else if(cornersAreBlocking) {
						if(checkPoint(y3,x3 - xstep)) {
							return false;
						}
						if(checkPoint(y3 - ystep,x3)) {
							return false;
						}
					}
				}
				if(checkPoint(y3,x3)) {
					return false;
				}
				errorprev = error;
			}
		}
		return true;
	}
	,__class__: Pathfinder
};
var Player = function(keyboard,world,game) {
	Focusable.call(this,keyboard,world,game);
	this.ownBody = new worldElements_creatures_Human(world,new common_Point(1,1));
	this.ownBody.movement.autoMove = false;
	world.addElement(this.ownBody);
	this.controllingBody = this.ownBody;
	this.statusEffectsMenuKey = Keyboard.getLetterCode("e");
	this.actionsKey = 16;
	this.waitKey = 190;
	this.ownBody.actions.push(new worldElements_creatures_actions_Dash(this.ownBody));
	this.ownBody.actions.push(new worldElements_creatures_actions_TakeOverEnemy(this.ownBody));
};
Player.__name__ = true;
Player.__super__ = Focusable;
Player.prototype = $extend(Focusable.prototype,{
	get_showsWorld: function() {
		return true;
	}
	,afterTakeover: function() {
		this.controllingBody.movement.autoMove = false;
		this.controllingBody.actions.push(new worldElements_creatures_actions_StopTakeOver(this.ownBody));
	}
	,stopTakeover: function() {
		if(this.controllingBody.stats.hp > 0) {
			this.controllingBody.movement.autoMove = true;
			var stopTakeOverAction = Lambda.find(this.controllingBody.actions,function(ac) {
				return js_Boot.__instanceof(ac,worldElements_creatures_actions_StopTakeOver);
			});
			if(stopTakeOverAction != null) {
				HxOverrides.remove(this.controllingBody.actions,stopTakeOverAction);
			}
		}
		this.controllingBody = this.ownBody;
	}
	,update: function() {
		if(this.ownBody.stats.hp <= 0) {
			if(this.keyboard.anyConfirm()) {
				this.game.restartGame();
			}
			return;
		}
		var xMove = 0;
		var yMove = 0;
		if(this.keyboard.leftKey()) {
			--xMove;
		}
		if(this.keyboard.rightKey()) {
			++xMove;
		}
		if(this.keyboard.upKey()) {
			--yMove;
		}
		if(this.keyboard.downKey()) {
			++yMove;
		}
		var moveDirection = null;
		if(xMove == -1) {
			moveDirection = common_Direction.Left;
		} else if(xMove == 1) {
			moveDirection = common_Direction.Right;
		} else if(yMove == -1) {
			moveDirection = common_Direction.Up;
		} else if(yMove == 1) {
			moveDirection = common_Direction.Down;
		}
		if(moveDirection != null) {
			if(this.controllingBody.movement.canMove(this.world,this.controllingBody,moveDirection)) {
				this.game.beforeStep();
				this.controllingBody.movement.moveInDirection(this.world,this.controllingBody,moveDirection);
				this.controllingBody.hasMoved = true;
				this.game.afterStep();
			}
		} else if(this.keyboard.pressed[this.actionsKey]) {
			this.showActions();
		} else if(this.keyboard.pressed[this.statusEffectsMenuKey]) {
			this.showStatusEffects();
		} else if(this.keyboard.pressed[this.waitKey]) {
			this.game.beforeStep();
			this.game.afterStep();
		}
	}
	,afterStep: function() {
		if(this.ownBody.stats.hp <= 0) {
			this.controllingBody = this.ownBody;
			this.world.addElement(new worldElements_PlayerBody(this.world,new common_Point(this.ownBody.position.x,this.ownBody.position.y)));
			this.game.info.addInfo("You are dead! Press Space or Enter to restart.");
		} else if(this.controllingBody.stats.hp <= 0) {
			this.stopTakeover();
			this.game.info.addInfo("You found yourself back in your own body.");
		}
	}
	,showStatusEffects: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.controllingBody.statusEffects;
		while(_g1 < _g2.length) {
			var statusEffect = _g2[_g1];
			++_g1;
			_g.push(new ui_MenuItem(statusEffect.name,statusEffect.getText(),function() {
			}));
		}
		var statusEffectMenuItems = _g;
		var menu;
		statusEffectMenuItems.push(new ui_MenuItem("Close Menu","",function() {
			menu.close();
		}));
		menu = new ui_Menu(this.game.drawer,this.keyboard,this.world,this.game,this,"Status Effects",statusEffectMenuItems,this.statusEffectsMenuKey);
		this.game.focus(menu);
	}
	,showActions: function() {
		var _gthis = this;
		var actionMenuItems = [];
		var menu;
		var showFail = function(text) {
			menu.info.clear();
			_gthis.game.focus(menu);
			menu.info.addInfo(text);
			menu.info.processInfo(_gthis.game.drawer);
		};
		var _g = 0;
		var _g1 = this.controllingBody.actions;
		while(_g < _g1.length) {
			var action = [_g1[_g]];
			++_g;
			if(action[0] != this.controllingBody.basicAttack) {
				actionMenuItems.push(new ui_MenuItem(action[0].abilityName + " (" + action[0].get_actionPoints() + " AP)",action[0].abilityDescription,(function(action1) {
					return function() {
						if(_gthis.controllingBody.stats.ap >= action1[0].get_actionPoints()) {
							if(js_Boot.__instanceof(action1[0],worldElements_creatures_actions_DirectionAction)) {
								var directionAction = action1[0];
								var dirMenu = new ui_ChooseDirection(_gthis.keyboard,_gthis.world,_gthis.game,"Choose a direction to use " + action1[0].abilityName + ".",(function(action2) {
									return function(dir) {
										directionAction.setParameter(dir);
										if(directionAction.canUse()) {
											_gthis.controllingBody.stats.ap -= action2[0].get_actionPoints();
											_gthis.game.focus(_gthis,false);
											_gthis.game.beforeStep();
											directionAction["use"]();
											_gthis.controllingBody.hasMoved = true;
											_gthis.game.afterStep();
										} else {
											showFail("You can't use " + action2[0].abilityName + " in that direction!");
										}
									};
								})(action1),menu);
								_gthis.game.focus(dirMenu);
							} else if(action1[0].canUse()) {
								_gthis.controllingBody.stats.ap -= action1[0].get_actionPoints();
								_gthis.game.focus(_gthis,false);
								_gthis.game.beforeStep();
								action1[0]["use"]();
								_gthis.controllingBody.hasMoved = true;
								_gthis.game.afterStep();
							} else {
								showFail("You can't use " + action1[0].abilityName + " at the moment!");
							}
						} else {
							showFail("You don't have enough AP to use " + action1[0].abilityName + "!");
						}
					};
				})(action)));
			}
		}
		actionMenuItems.push(new ui_MenuItem("Close Menu","",function() {
			menu.close();
		}));
		menu = new ui_Menu(this.game.drawer,this.keyboard,this.world,this.game,this,"Abilities",actionMenuItems,this.actionsKey);
		this.game.focus(menu);
	}
	,__class__: Player
});
var Std = function() { };
Std.__name__ = true;
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = true;
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Type = function() { };
Type.__name__ = true;
Type.createInstance = function(cl,args) {
	var _g = args.length;
	switch(_g) {
	case 0:
		return new cl();
	case 1:
		return new cl(args[0]);
	case 2:
		return new cl(args[0],args[1]);
	case 3:
		return new cl(args[0],args[1],args[2]);
	case 4:
		return new cl(args[0],args[1],args[2],args[3]);
	case 5:
		return new cl(args[0],args[1],args[2],args[3],args[4]);
	case 6:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5]);
	case 7:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	case 8:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	case 9:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);
	case 10:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
	case 11:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10]);
	case 12:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11]);
	case 13:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12]);
	case 14:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13]);
	default:
		throw new js__$Boot_HaxeError("Too many arguments");
	}
};
var World = function(drawer) {
	this.viewY = 0;
	this.viewX = 0;
	this.height = 20;
	this.width = 50;
	this.drawer = drawer;
	this.pathfinder = new Pathfinder(this);
	this.elements = [];
	var _g = [];
	var _g2 = 0;
	var _g1 = this.width;
	while(_g2 < _g1) {
		var i = _g2++;
		var _g3 = [];
		var _g5 = 0;
		var _g4 = this.height;
		while(_g5 < _g4) {
			var j = _g5++;
			_g3.push([]);
		}
		_g.push(_g3);
	}
	this.elementsByPosition = _g;
	this.elements.push(new worldElements_Wall(this,new common_Point(0,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(1,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(2,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(3,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(2,1)));
	this.elements.push(new worldElements_Wall(this,new common_Point(2,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(4,1)));
	this.elements.push(new worldElements_Wall(this,new common_Point(3,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(4,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(5,2)));
	this.elements.push(new worldElements_Wall(this,new common_Point(6,1)));
	this.elements.push(new worldElements_Wall(this,new common_Point(3,1)));
	this.elements.push(new worldElements_creatures_Rat(this,new common_Point(5,4)));
	this.elements.push(new worldElements_creatures_Rat(this,new common_Point(5,5)));
	this.elements.push(new worldElements_creatures_Rat(this,new common_Point(5,6)));
	this.elements.push(new worldElements_creatures_Goblin(this,new common_Point(7,3)));
	this.elements.push(new worldElements_creatures_Goblin(this,new common_Point(9,2)));
	this.elements.push(new worldElements_creatures_Goblin(this,new common_Point(11,4)));
};
World.__name__ = true;
World.prototype = {
	get_creatures: function() {
		return this.elements.filter(function(elem) {
			return js_Boot.__instanceof(elem,worldElements_creatures_Creature);
		}).map(function(elem1) {
			return elem1;
		});
	}
	,generateLevel: function() {
		new dungeonGeneration_DungeonGenerator(this);
	}
	,addElement: function(element) {
		this.elements.push(element);
	}
	,addToElementsAtPosition: function(element,position) {
		this.elementsByPosition[position.x][position.y].push(element);
	}
	,removeFromElementsAtPosition: function(element,position) {
		HxOverrides.remove(this.elementsByPosition[position.x][position.y],element);
	}
	,preUpdate: function() {
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.preUpdate();
		}
	}
	,update: function() {
		this.removeElementsWhereNeeded();
		this.extraUpdates = [];
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.update();
		}
		while(this.extraUpdates.length > 0) {
			this.removeElementsWhereNeeded();
			var processExtraUpdates = this.extraUpdates.slice();
			this.extraUpdates = [];
			var _g2 = 0;
			while(_g2 < processExtraUpdates.length) {
				var elem = processExtraUpdates[_g2];
				++_g2;
				elem.preUpdate();
				elem.update(true);
			}
		}
		this.removeElementsWhereNeeded();
		var _g3 = 0;
		var _g11 = this.elements;
		while(_g3 < _g11.length) {
			var element1 = _g11[_g3];
			++_g3;
			element1.postUpdate();
		}
		this.removeElementsWhereNeeded();
		this.player.afterStep();
		this.draw();
	}
	,requestExtraUpdate: function(elem) {
		this.extraUpdates.push(elem);
	}
	,removeElementsWhereNeeded: function() {
		var i = this.elements.length - 1;
		while(i >= 0) {
			var element = this.elements[i];
			if(element.shouldRemove()) {
				this.removeFromElementsAtPosition(element,element.position);
				this.elements.splice(i,1);
			}
			--i;
		}
	}
	,draw: function() {
		var _gthis = this;
		this.drawer.setWorldView(0,2,this.viewX,this.viewY,50,20);
		var visibleElements = [];
		var _g = [];
		var _g2 = 0;
		var _g1 = this.width;
		while(_g2 < _g1) {
			var i = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.height;
			while(_g5 < _g4) {
				var j = _g5++;
				_g3.push(false);
			}
			_g.push(_g3);
		}
		var elemAt = _g;
		var _g11 = 0;
		var _g21 = this.elements;
		while(_g11 < _g21.length) {
			var element = _g21[_g11];
			++_g11;
			element.isCurrentlyVisible = false;
			if(this.pathfinder.isVisible(this.player.controllingBody.position,element.position,true)) {
				visibleElements.push(element);
				elemAt[element.position.x][element.position.y] = true;
			} else if(element.get_isEasierVisible()) {
				var nowSeen = false;
				var anyIndirectlyVisible = [false];
				this.forEachDirectionFromPoint(element.position,(function(anyIndirectlyVisible1) {
					return function(p) {
						if(_gthis.pathfinder.isVisible(_gthis.player.controllingBody.position,p,true) && _gthis.noBlockingElementsAt(p)) {
							anyIndirectlyVisible1[0] = true;
						}
					};
				})(anyIndirectlyVisible));
				if(anyIndirectlyVisible[0]) {
					nowSeen = true;
					visibleElements.push(element);
					elemAt[element.position.x][element.position.y] = true;
				}
				if(!nowSeen && element.get_isStatic() && element.seenByPlayer) {
					element.draw(this.drawer,true);
					element.isCurrentlyVisible = true;
				}
			} else if(element.get_isStatic() && element.seenByPlayer) {
				element.draw(this.drawer,true);
			}
		}
		var _g12 = [];
		var _g31 = 0;
		var _g22 = this.width;
		while(_g31 < _g22) {
			var i1 = _g31++;
			var _g41 = [];
			var _g6 = 0;
			var _g51 = this.height;
			while(_g6 < _g51) {
				var j1 = _g6++;
				_g41.push(false);
			}
			_g12.push(_g41);
		}
		var shouldBeVisible = _g12;
		var floodFill = null;
		floodFill = function(x,y) {
			shouldBeVisible[x][y] = true;
			var xx = x - 1;
			var yy = y;
			if(_gthis.isPositionInWorld(new common_Point(xx,yy)) && (!shouldBeVisible[xx][yy] && elemAt[xx][yy])) {
				floodFill(xx,yy);
			}
			var xx1 = x + 1;
			var yy1 = y;
			if(_gthis.isPositionInWorld(new common_Point(xx1,yy1)) && (!shouldBeVisible[xx1][yy1] && elemAt[xx1][yy1])) {
				floodFill(xx1,yy1);
			}
			var xx2 = x;
			var yy2 = y - 1;
			if(_gthis.isPositionInWorld(new common_Point(xx2,yy2)) && (!shouldBeVisible[xx2][yy2] && elemAt[xx2][yy2])) {
				floodFill(xx2,yy2);
			}
			var xx3 = x;
			var yy3 = y + 1;
			if(_gthis.isPositionInWorld(new common_Point(xx3,yy3)) && (!shouldBeVisible[xx3][yy3] && elemAt[xx3][yy3])) {
				floodFill(xx3,yy3);
			}
		};
		var floodFill1 = floodFill;
		floodFill1(this.player.controllingBody.position.x,this.player.controllingBody.position.y);
		var _g23 = 0;
		while(_g23 < visibleElements.length) {
			var element1 = visibleElements[_g23];
			++_g23;
			if(shouldBeVisible[element1.position.x][element1.position.y]) {
				element1.isCurrentlyVisible = true;
				element1.draw(this.drawer,false);
				element1.seenByPlayer = true;
			}
		}
		var _g24 = 0;
		var _g32 = this.elements;
		while(_g24 < _g32.length) {
			var element2 = _g32[_g24];
			++_g24;
			if(js_Boot.__instanceof(element2,worldElements_Wall)) {
				var wall = element2;
				if(!wall.seenByPlayer) {
					var allAroundSeen = [true];
					this.forEachDirectionFromPoint(wall.position,(function(allAroundSeen1) {
						return function(p1) {
							if(_gthis.noBlockingElementsAt(p1) || common_ArrayExtensions.any(_gthis.elementsAtPosition(p1),(function() {
								return function(elem) {
									if(elem.get_isViewBlocking()) {
										return !elem.seenByPlayer;
									} else {
										return false;
									}
								};
							})())) {
								allAroundSeen1[0] = false;
							}
						};
					})(allAroundSeen));
					if(allAroundSeen[0]) {
						wall.seenByPlayer = true;
						wall.draw(this.drawer,true);
						wall.isCurrentlyVisible = true;
					}
				}
			}
		}
	}
	,positionInDirection: function(position,direction) {
		var newPosition = new common_Point(position.x,position.y);
		switch(direction[1]) {
		case 0:
			newPosition.x -= 1;
			break;
		case 1:
			newPosition.x += 1;
			break;
		case 2:
			newPosition.y -= 1;
			break;
		case 3:
			newPosition.y += 1;
			break;
		}
		if(this.isPositionInWorld(newPosition)) {
			return newPosition;
		} else {
			return null;
		}
	}
	,forEachDirectionFromPoint: function(position,functionToExecute) {
		var left = new common_Point(position.x - 1,position.y);
		if(this.isPositionInWorld(left)) {
			functionToExecute(left);
		}
		var right = new common_Point(position.x + 1,position.y);
		if(this.isPositionInWorld(right)) {
			functionToExecute(right);
		}
		var up = new common_Point(position.x,position.y - 1);
		if(this.isPositionInWorld(up)) {
			functionToExecute(up);
		}
		var down = new common_Point(position.x,position.y + 1);
		if(this.isPositionInWorld(down)) {
			functionToExecute(down);
		}
	}
	,isPositionInWorld: function(position) {
		if(position.x >= 0 && position.y >= 0 && position.x < this.width) {
			return position.y < this.height;
		} else {
			return false;
		}
	}
	,elementsAtPosition: function(position) {
		return this.elementsByPosition[position.x][position.y];
	}
	,noBlockingElementsAt: function(position,viewBlockingOnly) {
		if(viewBlockingOnly == null) {
			viewBlockingOnly = true;
		}
		return !common_ArrayExtensions.any(this.elementsAtPosition(position),function(elem) {
			if(viewBlockingOnly) {
				return elem.get_isViewBlocking();
			} else {
				return elem.get_isBlocking();
			}
		});
	}
	,toWorldPoint: function(point) {
		var newPoint = new common_Point(point.x,point.y);
		newPoint.x -= this.viewX;
		newPoint.y -= 2 + this.viewY;
		if(this.isPositionInWorld(newPoint)) {
			return newPoint;
		} else {
			return null;
		}
	}
	,getQuickExamine: function(position) {
		var help = "";
		var _g = 0;
		var _g1 = this.elementsAtPosition(position);
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			if(element.isCurrentlyVisible) {
				var thisInfo = element.getInfo();
				if(thisInfo != "") {
					if(help != "") {
						help += "\n";
					}
					help += thisInfo;
				}
			}
		}
		return help;
	}
	,__class__: World
};
var common_ArrayExtensions = function() { };
common_ArrayExtensions.__name__ = true;
common_ArrayExtensions.min = function(array,fn) {
	if(fn == null) {
		fn = function(val) {
			return val;
		};
	}
	var arrayMinVal = Infinity;
	var arrayMinItem = null;
	var _g = 0;
	while(_g < array.length) {
		var item = array[_g];
		++_g;
		var val1 = fn(item);
		if(val1 < arrayMinVal) {
			arrayMinItem = item;
			arrayMinVal = val1;
		}
	}
	return arrayMinItem;
};
common_ArrayExtensions.any = function(array,fn) {
	var _g = 0;
	while(_g < array.length) {
		var val = array[_g];
		++_g;
		if(fn(val)) {
			return true;
		}
	}
	return false;
};
common_ArrayExtensions.contains = function(array,element) {
	return array.indexOf(element) != -1;
};
var common_Rectangle = function(x,y,width,height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
common_Rectangle.__name__ = true;
common_Rectangle.prototype = {
	get_x2: function() {
		return this.x + this.width;
	}
	,get_y2: function() {
		return this.y + this.height;
	}
	,get_centerX: function() {
		return this.x + (this.width / 2 | 0);
	}
	,get_centerY: function() {
		return this.y + (this.height / 2 | 0);
	}
	,overlaps: function(other) {
		if(this.x < other.get_x2() && this.get_x2() > other.x && this.y < other.get_y2()) {
			return this.get_y2() > other.y;
		} else {
			return false;
		}
	}
	,__class__: common_Rectangle
};
var common_Point = function(x,y) {
	this.x = x;
	this.y = y;
};
common_Point.__name__ = true;
common_Point.prototype = {
	__class__: common_Point
};
var common_Direction = { __ename__ : true, __constructs__ : ["Left","Right","Up","Down"] };
common_Direction.Left = ["Left",0];
common_Direction.Left.toString = $estr;
common_Direction.Left.__enum__ = common_Direction;
common_Direction.Right = ["Right",1];
common_Direction.Right.toString = $estr;
common_Direction.Right.__enum__ = common_Direction;
common_Direction.Up = ["Up",2];
common_Direction.Up.toString = $estr;
common_Direction.Up.__enum__ = common_Direction;
common_Direction.Down = ["Down",3];
common_Direction.Down.toString = $estr;
common_Direction.Down.__enum__ = common_Direction;
var common_Random = function() { };
common_Random.__name__ = true;
common_Random.getFloat = function(val0,val1) {
	var min = 0;
	var max = 1;
	if(val0 != null && val1 != null) {
		min = val0;
		max = val1;
	} else if(val0 != null) {
		max = val0;
	}
	return Math.random() * (max - min) + min;
};
common_Random.getInt = function(val0,val1) {
	var min = 0;
	var max = 2147483647;
	if(val0 != null && val1 != null) {
		min = val0;
		max = val1;
	} else if(val0 != null) {
		max = val0;
	}
	return Math.floor(Math.random() * (max - min)) + min;
};
common_Random.fromArray = function(arr) {
	if(arr.length == 0) {
		throw new js__$Boot_HaxeError("You can't get a random item from an empty array!");
	}
	return arr[common_Random.getInt(arr.length)];
};
var de_polygonal_ds_Hashable = function() { };
de_polygonal_ds_Hashable.__name__ = true;
var de_polygonal_ds_Collection = function() { };
de_polygonal_ds_Collection.__name__ = true;
de_polygonal_ds_Collection.__interfaces__ = [de_polygonal_ds_Hashable];
de_polygonal_ds_Collection.prototype = {
	__class__: de_polygonal_ds_Collection
};
var de_polygonal_ds_Queue = function() { };
de_polygonal_ds_Queue.__name__ = true;
de_polygonal_ds_Queue.__interfaces__ = [de_polygonal_ds_Collection];
var de_polygonal_ds_ArrayedQueue = function(initialCapacity,source,fixed) {
	if(initialCapacity == null) {
		initialCapacity = 16;
	}
	this.mFront = 0;
	this.mSize = 0;
	this.growthRate = -2;
	this.mInitialCapacity = 1 > initialCapacity ? 1 : initialCapacity;
	this.capacity = this.mInitialCapacity;
	if(source != null) {
		this.mSize = source.length;
		var x = this.mSize;
		var y = this.capacity;
		this.capacity = x > y ? x : y;
	}
	var len = this.capacity;
	this.mData = new Array(len);
	if(source != null) {
		var d = this.mData;
		var _g1 = 0;
		var _g = this.mSize;
		while(_g1 < _g) {
			var i = _g1++;
			d[i] = source[i];
		}
	}
	if(fixed) {
		this.growthRate = 0;
	}
};
de_polygonal_ds_ArrayedQueue.__name__ = true;
de_polygonal_ds_ArrayedQueue.__interfaces__ = [de_polygonal_ds_Queue];
de_polygonal_ds_ArrayedQueue.prototype = {
	grow: function() {
		var t = this.capacity;
		this.capacity = de_polygonal_ds_tools_GrowthRate.compute(this.growthRate,this.capacity);
		this.resizeContainer(t,this.capacity);
	}
	,resizeContainer: function(oldSize,newSize) {
		var dst = new Array(newSize);
		if(oldSize < newSize) {
			if(this.mFront + this.mSize > oldSize) {
				var n1 = oldSize - this.mFront;
				var n2 = oldSize - n1;
				de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,n1);
				de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,0,dst,n1,n2);
			} else {
				de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,this.mSize);
			}
		} else if(this.mFront + this.mSize > oldSize) {
			var n11 = oldSize - this.mFront;
			var n21 = this.mSize - this.mFront;
			de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,n11);
			de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,0,dst,this.mFront,n21);
		} else {
			de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,this.mFront,dst,0,this.mSize);
		}
		this.mData = dst;
		this.mFront = 0;
	}
	,__class__: de_polygonal_ds_ArrayedQueue
};
var de_polygonal_ds_tools_AssertError = function(message,info) {
	if(message == null) {
		message = "";
	}
	this.message = message;
	var stack = haxe_CallStack.toString(haxe_CallStack.callStack());
	var _this_r = new RegExp("\nCalled from de\\.polygonal\\.ds\\.tools\\.AssertError.*$","m".split("u").join(""));
	stack = stack.replace(_this_r,"");
	this.message = "Assertation " + message + " failed in file " + info.fileName + ", line " + info.lineNumber + ", " + info.className + ":: " + info.methodName + "\nCall stack:" + stack;
};
de_polygonal_ds_tools_AssertError.__name__ = true;
de_polygonal_ds_tools_AssertError.prototype = {
	toString: function() {
		return this.message;
	}
	,__class__: de_polygonal_ds_tools_AssertError
};
var de_polygonal_ds_tools_GrowthRate = function() { };
de_polygonal_ds_tools_GrowthRate.__name__ = true;
de_polygonal_ds_tools_GrowthRate.compute = function(rate,capacity) {
	if(true != rate >= -3) {
		throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("invalid growth rate" + " (rate >= -3)",{ fileName : "GrowthRate.hx", lineNumber : 52, className : "de.polygonal.ds.tools.GrowthRate", methodName : "compute"}));
	}
	if(rate > 0) {
		capacity += rate;
	} else {
		switch(rate) {
		case -3:
			capacity <<= 1;
			break;
		case -2:
			capacity = (capacity * 3 >> 1) + 1;
			break;
		case -1:
			var newSize = capacity + 1;
			capacity = (newSize >> 3) + (newSize < 9 ? 3 : 6);
			capacity += newSize;
			break;
		case 0:
			throw new js__$Boot_HaxeError("out of space");
			break;
		}
	}
	return capacity;
};
var de_polygonal_ds_tools_NativeArrayTools = function() { };
de_polygonal_ds_tools_NativeArrayTools.__name__ = true;
de_polygonal_ds_tools_NativeArrayTools.blit = function(src,srcPos,dst,dstPos,n) {
	if(n > 0) {
		if(true != srcPos < src.length) {
			throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("srcPos out of range" + " (srcPos < size(src))",{ fileName : "NativeArrayTools.hx", lineNumber : 187, className : "de.polygonal.ds.tools.NativeArrayTools", methodName : "blit"}));
		}
		if(true != dstPos < dst.length) {
			throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("dstPos out of range" + " (dstPos < size(dst))",{ fileName : "NativeArrayTools.hx", lineNumber : 188, className : "de.polygonal.ds.tools.NativeArrayTools", methodName : "blit"}));
		}
		if(true != (srcPos + n <= src.length && dstPos + n <= dst.length)) {
			throw new js__$Boot_HaxeError(new de_polygonal_ds_tools_AssertError("n out of range" + " (srcPos + n <= size(src) && dstPos + n <= size(dst))",{ fileName : "NativeArrayTools.hx", lineNumber : 189, className : "de.polygonal.ds.tools.NativeArrayTools", methodName : "blit"}));
		}
		if(src == dst) {
			if(srcPos < dstPos) {
				var i = srcPos + n;
				var j = dstPos + n;
				var _g1 = 0;
				var _g = n;
				while(_g1 < _g) {
					var k = _g1++;
					--i;
					--j;
					src[j] = src[i];
				}
			} else if(srcPos > dstPos) {
				var i1 = srcPos;
				var j1 = dstPos;
				var _g11 = 0;
				var _g2 = n;
				while(_g11 < _g2) {
					var k1 = _g11++;
					src[j1] = src[i1];
					++i1;
					++j1;
				}
			}
		} else if(srcPos == 0 && dstPos == 0) {
			var _g12 = 0;
			var _g3 = n;
			while(_g12 < _g3) {
				var i2 = _g12++;
				dst[i2] = src[i2];
			}
		} else if(srcPos == 0) {
			var _g13 = 0;
			var _g4 = n;
			while(_g13 < _g4) {
				var i3 = _g13++;
				dst[dstPos + i3] = src[i3];
			}
		} else if(dstPos == 0) {
			var _g14 = 0;
			var _g5 = n;
			while(_g14 < _g5) {
				var i4 = _g14++;
				dst[i4] = src[srcPos + i4];
			}
		} else {
			var _g15 = 0;
			var _g6 = n;
			while(_g15 < _g6) {
				var i5 = _g15++;
				dst[dstPos + i5] = src[srcPos + i5];
			}
		}
	}
};
var dungeonGeneration_RoomType = { __ename__ : true, __constructs__ : ["PlayerStart","Treasure","Monsters","End","None"] };
dungeonGeneration_RoomType.PlayerStart = ["PlayerStart",0];
dungeonGeneration_RoomType.PlayerStart.toString = $estr;
dungeonGeneration_RoomType.PlayerStart.__enum__ = dungeonGeneration_RoomType;
dungeonGeneration_RoomType.Treasure = ["Treasure",1];
dungeonGeneration_RoomType.Treasure.toString = $estr;
dungeonGeneration_RoomType.Treasure.__enum__ = dungeonGeneration_RoomType;
dungeonGeneration_RoomType.Monsters = ["Monsters",2];
dungeonGeneration_RoomType.Monsters.toString = $estr;
dungeonGeneration_RoomType.Monsters.__enum__ = dungeonGeneration_RoomType;
dungeonGeneration_RoomType.End = ["End",3];
dungeonGeneration_RoomType.End.toString = $estr;
dungeonGeneration_RoomType.End.__enum__ = dungeonGeneration_RoomType;
dungeonGeneration_RoomType.None = ["None",4];
dungeonGeneration_RoomType.None.toString = $estr;
dungeonGeneration_RoomType.None.__enum__ = dungeonGeneration_RoomType;
var dungeonGeneration_DungeonGenerator = function(world,floor) {
	if(floor == null) {
		floor = 1;
	}
	this.world = world;
	this.floor = floor;
	this.width = world.width;
	this.height = world.height;
	this.playerBody = world.player.ownBody;
	this.clearWorld();
	this.generateWorld();
};
dungeonGeneration_DungeonGenerator.__name__ = true;
dungeonGeneration_DungeonGenerator.lineIntersectsRect = function(rect,p1X,p1Y,p2X,p2Y) {
	return dungeonGeneration_DungeonGenerator.segmentIntersectRectangle(rect.x,rect.y,rect.x + rect.width,rect.y + rect.height,p1X,p1Y,p2X,p2Y);
};
dungeonGeneration_DungeonGenerator.segmentIntersectRectangle = function(rectangleMinX,rectangleMinY,rectangleMaxX,rectangleMaxY,p1X,p1Y,p2X,p2Y) {
	var minX = p1X;
	var maxX = p2X;
	if(p1X > p2X) {
		minX = p2X;
		maxX = p1X;
	}
	if(maxX > rectangleMaxX) {
		maxX = rectangleMaxX;
	}
	if(minX < rectangleMinX) {
		minX = rectangleMinX;
	}
	if(minX > maxX) {
		return false;
	}
	var minY = p1Y;
	var maxY = p2Y;
	var dx = p2X - p1X;
	if(Math.abs(dx) > 0.0000001) {
		var a = (p2Y - p1Y) / dx;
		var b = p1Y - a * p1X;
		minY = a * minX + b;
		maxY = a * maxX + b;
	}
	if(minY > maxY) {
		var tmp = maxY;
		maxY = minY;
		minY = tmp;
	}
	if(maxY > rectangleMaxY) {
		maxY = rectangleMaxY;
	}
	if(minY < rectangleMinY) {
		minY = rectangleMinY;
	}
	if(minY > maxY) {
		return false;
	}
	return true;
};
dungeonGeneration_DungeonGenerator.prototype = {
	clearWorld: function() {
		this.world.elements = [];
		var _g = [];
		var _g2 = 0;
		var _g1 = this.width;
		while(_g2 < _g1) {
			var i = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.height;
			while(_g5 < _g4) {
				var j = _g5++;
				_g3.push([]);
			}
			_g.push(_g3);
		}
		this.world.elementsByPosition = _g;
	}
	,generateWorld: function() {
		this.generateBasicDungeon();
	}
	,generateBasicDungeon: function() {
		var _g = [];
		var _g2 = 0;
		var _g1 = this.width;
		while(_g2 < _g1) {
			var x = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.height;
			while(_g5 < _g4) {
				var y = _g5++;
				_g3.push(false);
			}
			_g.push(_g3);
		}
		var basicDungeon = _g;
		var rooms = [];
		var minWidth = 3;
		var maxWidth = 6;
		var minHeight = 3;
		var maxHeight = 6;
		var minDistance = 2;
		var minimumRoomAmount = common_Random.getInt(11,16);
		var maxIterations = 10000;
		var i = 0;
		while(rooms.length < minimumRoomAmount && ++i < maxIterations) {
			var rectWidth = common_Random.getInt(minWidth,maxWidth);
			var rectHeight = common_Random.getInt(minHeight,maxHeight);
			if(rectWidth == 3 && rectHeight == 3) {
				if(common_Random.getInt(2) == 1) {
					rectWidth = 4;
				} else {
					rectHeight = 4;
				}
			}
			var newRoom = new common_Rectangle(common_Random.getInt(1,this.width - rectWidth),common_Random.getInt(1,this.height - rectHeight),rectWidth,rectHeight);
			var newRoomCollider = new common_Rectangle(newRoom.x - minDistance,newRoom.y - minDistance,newRoom.width + minDistance * 2,newRoom.height + minDistance * 2);
			var overlaps = false;
			var _g11 = 0;
			while(_g11 < rooms.length) {
				var rect = rooms[_g11];
				++_g11;
				if(rect.overlaps(newRoomCollider)) {
					overlaps = true;
					break;
				}
			}
			if(!overlaps) {
				rooms.push(newRoom);
			}
		}
		var paths = [];
		var _g21 = 0;
		var _g12 = rooms.length;
		while(_g21 < _g12) {
			var i1 = _g21++;
			var room = rooms[i1];
			var _g41 = i1 + 1;
			var _g31 = rooms.length;
			while(_g41 < _g31) {
				var j = _g41++;
				var otherRoom = rooms[j];
				var hasIntersection = false;
				var _g51 = 0;
				while(_g51 < rooms.length) {
					var possiblyIntersectingRoom = rooms[_g51];
					++_g51;
					if(possiblyIntersectingRoom == room || possiblyIntersectingRoom == otherRoom) {
						continue;
					}
					if(dungeonGeneration_DungeonGenerator.lineIntersectsRect(possiblyIntersectingRoom,room.get_centerX(),room.get_centerY(),otherRoom.get_centerX(),otherRoom.get_centerY())) {
						hasIntersection = true;
						break;
					}
				}
				if(!hasIntersection) {
					paths.push(new dungeonGeneration_RoomPath(room,otherRoom));
				}
			}
		}
		var retry = true;
		var newPaths = [];
		while(retry) {
			retry = false;
			var unusedRooms = rooms.slice();
			var usedRooms = [rooms[0]];
			HxOverrides.remove(unusedRooms,usedRooms[0]);
			while(unusedRooms.length >= 0) {
				var minimumWidthPath = null;
				var minimumLength = 100000.0;
				var newPathRoom = null;
				var _g13 = 0;
				while(_g13 < paths.length) {
					var path = paths[_g13];
					++_g13;
					var wouldBeNewRoom = null;
					if(common_ArrayExtensions.contains(unusedRooms,path.room1) && common_ArrayExtensions.contains(usedRooms,path.room2)) {
						wouldBeNewRoom = path.room1;
					} else if(common_ArrayExtensions.contains(unusedRooms,path.room2) && common_ArrayExtensions.contains(usedRooms,path.room1)) {
						wouldBeNewRoom = path.room2;
					}
					if(wouldBeNewRoom != null) {
						var _this_y;
						var _this_x = path.room1.get_centerX();
						_this_y = path.room1.get_centerY();
						var otherPoint_y;
						var otherPoint_x = path.room2.get_centerX();
						otherPoint_y = path.room2.get_centerY();
						var len = Math.abs(_this_x - otherPoint_x) + Math.abs(_this_y - otherPoint_y);
						if(len < minimumLength) {
							minimumLength = len;
							newPathRoom = wouldBeNewRoom;
							minimumWidthPath = path;
						}
					}
				}
				if(minimumWidthPath == null) {
					if(unusedRooms.length >= 3) {
						retry = true;
						newPaths = [];
					} else {
						var _g14 = 0;
						while(_g14 < unusedRooms.length) {
							var room1 = unusedRooms[_g14];
							++_g14;
							HxOverrides.remove(rooms,room1);
						}
					}
					break;
				} else {
					HxOverrides.remove(unusedRooms,newPathRoom);
					usedRooms.push(newPathRoom);
					newPaths.push(minimumWidthPath);
				}
			}
		}
		var oldPaths = paths;
		paths = newPaths;
		var suboptimalsFrom = paths.length;
		var _g15 = 0;
		while(_g15 < 5) {
			var i2 = _g15++;
			var path1 = common_Random.fromArray(oldPaths);
			if(!common_ArrayExtensions.contains(paths,path1)) {
				paths.push(path1);
			}
		}
		var _g16 = 0;
		while(_g16 < rooms.length) {
			var room2 = rooms[_g16];
			++_g16;
			var _g32 = 0;
			var _g22 = room2.width;
			while(_g32 < _g22) {
				var i3 = _g32++;
				var _g52 = 0;
				var _g42 = room2.height;
				while(_g52 < _g42) {
					var j1 = _g52++;
					basicDungeon[room2.x + i3][room2.y + j1] = true;
				}
			}
		}
		var _g23 = 0;
		var _g17 = paths.length;
		while(_g23 < _g17) {
			var i4 = _g23++;
			var path2 = paths[i4];
			var isSuboptimal = i4 >= suboptimalsFrom;
			var setBasicDungeon = function(x1,y1) {
				basicDungeon[x1][y1] = true;
				return false;
			};
			var room11 = path2.room1;
			var room21 = path2.room2;
			var leftRoom = room11.x < room21.x ? room11 : room21;
			var rightRoom = room11 == leftRoom ? room21 : room11;
			var topRoom = room11.y < room21.y ? room11 : room21;
			var bottomRoom = room11 == topRoom ? room21 : room11;
			var val1 = room11.y;
			var val2 = room21.y;
			var yOverlapMin = val2 > val1 ? val2 : val1;
			var val11 = room11.get_y2();
			var val21 = room21.get_y2();
			var yOverlapMax = val21 < val11 ? val21 : val11;
			if(yOverlapMax > yOverlapMin) {
				var yy = common_Random.getInt(yOverlapMin,yOverlapMax);
				var _g43 = leftRoom.get_x2();
				var _g33 = rightRoom.x;
				while(_g43 < _g33) {
					var xx = _g43++;
					if(setBasicDungeon(xx,yy)) {
						break;
					}
				}
				continue;
			}
			var val12 = room11.x;
			var val22 = room21.x;
			var xOverlapMin = val22 > val12 ? val22 : val12;
			var val13 = room11.get_x2();
			var val23 = room21.get_x2();
			var xOverlapMax = val23 < val13 ? val23 : val13;
			if(xOverlapMax > xOverlapMin) {
				var xx1 = common_Random.getInt(xOverlapMin,xOverlapMax);
				var _g44 = topRoom.get_y2();
				var _g34 = bottomRoom.y;
				while(_g44 < _g34) {
					var yy1 = _g44++;
					if(setBasicDungeon(xx1,yy1)) {
						break;
					}
				}
				continue;
			}
			if(common_Random.getInt(2) == 1) {
				var toX = common_Random.getInt(rightRoom.x,rightRoom.get_x2());
				var fromY = common_Random.getInt(leftRoom.y,leftRoom.get_y2());
				var stop = false;
				var _g45 = leftRoom.get_x2();
				var _g35 = toX + 1;
				while(_g45 < _g35) {
					var xx2 = _g45++;
					if(setBasicDungeon(xx2,fromY)) {
						stop = true;
						break;
					}
				}
				if(!stop) {
					var val14 = fromY + 1;
					var val24 = rightRoom.get_y2();
					var minY = val24 < val14 ? val24 : val14;
					var val25 = rightRoom.y;
					var maxY = val25 > fromY ? val25 : fromY;
					var _g46 = minY;
					var _g36 = maxY;
					while(_g46 < _g36) {
						var yy2 = _g46++;
						if(setBasicDungeon(toX,yy2)) {
							break;
						}
					}
				}
			} else {
				var toY = common_Random.getInt(bottomRoom.y,bottomRoom.get_y2());
				var fromX = common_Random.getInt(topRoom.x,topRoom.get_x2());
				var stop1 = false;
				var _g47 = topRoom.get_y2();
				var _g37 = toY + 1;
				while(_g47 < _g37) {
					var yy3 = _g47++;
					if(setBasicDungeon(fromX,yy3)) {
						stop1 = true;
						break;
					}
				}
				if(!stop1) {
					var val15 = fromX + 1;
					var val26 = bottomRoom.get_x2();
					var minX = val26 < val15 ? val26 : val15;
					var val27 = bottomRoom.x;
					var maxX = val27 > fromX ? val27 : fromX;
					var _g48 = minX;
					var _g38 = maxX;
					while(_g48 < _g38) {
						var xx3 = _g48++;
						if(setBasicDungeon(xx3,toY)) {
							break;
						}
					}
				}
			}
		}
		var _g24 = 0;
		var _g18 = this.width;
		while(_g24 < _g18) {
			var x2 = _g24++;
			var _g49 = 0;
			var _g39 = this.height;
			while(_g49 < _g39) {
				var y2 = _g49++;
				if(!basicDungeon[x2][y2]) {
					this.world.addElement(new worldElements_Wall(this.world,new common_Point(x2,y2)));
				} else {
					this.world.addElement(new worldElements_Floor(this.world,new common_Point(x2,y2)));
				}
			}
		}
		var roomFunction = new haxe_ds_ObjectMap();
		var _g19 = 0;
		while(_g19 < rooms.length) {
			var room3 = rooms[_g19];
			++_g19;
			var v = dungeonGeneration_RoomType.None;
			roomFunction.set(room3,v);
		}
		var playerRoom = common_ArrayExtensions.min(rooms,function(r) {
			return r.x;
		});
		var v1 = dungeonGeneration_RoomType.PlayerStart;
		roomFunction.set(playerRoom,v1);
		var getUnusedRooms = function() {
			return rooms.filter(function(r1) {
				return roomFunction.h[r1.__id__] == dungeonGeneration_RoomType.None;
			});
		};
		var getUnusedRoomsRandomOrder = function() {
			var unused = getUnusedRooms();
			unused.sort(function(_,_2) {
				return common_Random.fromArray([-1,1]);
			});
			return unused;
		};
		var roomsStillToFill = getUnusedRoomsRandomOrder();
		var _g25 = 0;
		var _g110 = roomsStillToFill.length - 2;
		while(_g25 < _g110) {
			var i5 = _g25++;
			var v2 = dungeonGeneration_RoomType.Monsters;
			roomFunction.set(roomsStillToFill[i5],v2);
		}
		var room4 = roomFunction.keys();
		while(room4.hasNext()) {
			var room5 = room4.next();
			var _g111 = roomFunction.h[room5.__id__];
			switch(_g111[1]) {
			case 0:
				this.playerBody.set_position(new common_Point(room5.get_centerX(),room5.get_centerY()));
				this.world.addElement(this.playerBody);
				break;
			case 1:
				break;
			case 2:
				this.addMonsters(room5);
				break;
			case 3:
				break;
			case 4:
				break;
			}
		}
		return basicDungeon;
	}
	,anyEmptyPositionInRoom: function(room) {
		var tries = 0;
		while(tries < 1000) {
			var pointX = common_Random.getInt(room.x,room.get_x2());
			var pointY = common_Random.getInt(room.y,room.get_y2());
			if(this.world.noBlockingElementsAt(new common_Point(pointX,pointY))) {
				return new common_Point(pointX,pointY);
			}
		}
		return null;
	}
	,addMonsters: function(room) {
		var points = 2 + common_Random.getInt(this.floor);
		var creatureOptions = [{ type : worldElements_creatures_Goblin, points : 2},{ type : worldElements_creatures_Rat, points : 1},{ type : worldElements_creatures_ManeatingPlant, points : 1}];
		var _g = 0;
		while(_g < 100) {
			var i = _g++;
			var creatureOption = common_Random.fromArray(creatureOptions);
			if(points >= creatureOption.points) {
				var position = this.anyEmptyPositionInRoom(room);
				this.world.addElement(Type.createInstance(creatureOption.type,[this.world,position]));
				points -= creatureOption.points;
			}
		}
	}
	,__class__: dungeonGeneration_DungeonGenerator
};
var dungeonGeneration_RoomPath = function(room1,room2) {
	this.room1 = room1;
	this.room2 = room2;
};
dungeonGeneration_RoomPath.__name__ = true;
dungeonGeneration_RoomPath.prototype = {
	__class__: dungeonGeneration_RoomPath
};
var haxe_StackItem = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"] };
haxe_StackItem.CFunction = ["CFunction",0];
haxe_StackItem.CFunction.toString = $estr;
haxe_StackItem.CFunction.__enum__ = haxe_StackItem;
haxe_StackItem.Module = function(m) { var $x = ["Module",1,m]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.FilePos = function(s,file,line) { var $x = ["FilePos",2,s,file,line]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.Method = function(classname,method) { var $x = ["Method",3,classname,method]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.LocalFunction = function(v) { var $x = ["LocalFunction",4,v]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
var haxe_CallStack = function() { };
haxe_CallStack.__name__ = true;
haxe_CallStack.getStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = function(error,callsites) {
		var stack = [];
		var _g = 0;
		while(_g < callsites.length) {
			var site = callsites[_g];
			++_g;
			if(haxe_CallStack.wrapCallSite != null) {
				site = haxe_CallStack.wrapCallSite(site);
			}
			var method = null;
			var fullName = site.getFunctionName();
			if(fullName != null) {
				var idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					var className = HxOverrides.substr(fullName,0,idx);
					var methodName = HxOverrides.substr(fullName,idx + 1,null);
					method = haxe_StackItem.Method(className,methodName);
				}
			}
			stack.push(haxe_StackItem.FilePos(method,site.getFileName(),site.getLineNumber()));
		}
		return stack;
	};
	var a = haxe_CallStack.makeStack(e.stack);
	Error.prepareStackTrace = oldValue;
	return a;
};
haxe_CallStack.callStack = function() {
	try {
		throw new Error();
	} catch( e ) {
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		var a = haxe_CallStack.getStack(e);
		a.shift();
		return a;
	}
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	while(_g < stack.length) {
		var s = stack[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s[1]) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s[2];
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var line = s[4];
		var file = s[3];
		var s1 = s[2];
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var meth = s[3];
		var cname = s[2];
		b.b += cname == null ? "null" : "" + cname;
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s[2];
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
haxe_CallStack.makeStack = function(s) {
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var rie10 = new EReg("^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$","");
		var _g = 0;
		while(_g < stack.length) {
			var line = stack[_g];
			++_g;
			if(rie10.match(line)) {
				var path = rie10.matched(1).split(".");
				var meth = path.pop();
				var file = rie10.matched(2);
				var line1 = Std.parseInt(rie10.matched(3));
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else {
		return s;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_web_Request = function() { };
haxe_web_Request.__name__ = true;
haxe_web_Request.getParams = function() {
	var get = HxOverrides.substr(window.location.search,1,null);
	var params = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = new EReg("[&;]","g").split(get);
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var pl = p.split("=");
		if(pl.length < 2) {
			continue;
		}
		var name = pl.shift();
		var key = decodeURIComponent(name.split("+").join(" "));
		var s = pl.join("=");
		var value = decodeURIComponent(s.split("+").join(" "));
		if(__map_reserved[key] != null) {
			params.setReserved(key,value);
		} else {
			params.h[key] = value;
		}
	}
	return params;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var ui_ChooseDirection = function(keyboard,world,game,info,chooseFunction,innerFocusable) {
	this.info = "";
	Focusable.call(this,keyboard,world,game);
	this.info = info;
	this.chooseFunction = chooseFunction;
	this.innerFocusable = innerFocusable;
	this.draw();
};
ui_ChooseDirection.__name__ = true;
ui_ChooseDirection.__super__ = Focusable;
ui_ChooseDirection.prototype = $extend(Focusable.prototype,{
	get_showsWorld: function() {
		return true;
	}
	,update: function() {
		if(this.keyboard.leftKey()) {
			this.chooseFunction(common_Direction.Left);
			return;
		}
		if(this.keyboard.rightKey()) {
			this.chooseFunction(common_Direction.Right);
			return;
		}
		if(this.keyboard.upKey()) {
			this.chooseFunction(common_Direction.Up);
			return;
		}
		if(this.keyboard.downKey()) {
			this.chooseFunction(common_Direction.Down);
			return;
		}
		if(this.keyboard.anyBack()) {
			this.game.focus(this.innerFocusable,false);
		}
	}
	,draw: function() {
		var drawer = this.game.drawer;
		drawer.clearLines(0,2);
		drawer.drawText(0,0,this.info);
	}
	,__class__: ui_ChooseDirection
});
var ui_InfoDisplay = function(keyboard,world,game,innerFocusable) {
	this.currentLine = 0;
	this.info = "";
	this.innerFocusable = innerFocusable;
	Focusable.call(this,keyboard,world,game);
};
ui_InfoDisplay.__name__ = true;
ui_InfoDisplay.__super__ = Focusable;
ui_InfoDisplay.prototype = $extend(Focusable.prototype,{
	get_showsWorld: function() {
		return this.innerFocusable.get_showsWorld();
	}
	,clear: function() {
		this.info = "";
	}
	,addInfo: function(info) {
		if(this.info != "") {
			this.info += " ";
		}
		this.info += info;
	}
	,draw: function() {
		this.drawCurrentLines(this.game.drawer);
	}
	,processInfo: function(drawer) {
		var addToLast = "...";
		var lines = drawer.splitIntoLines(0,0,this.info,null,null,function(orig,ln) {
			if(ln % 2 == 1) {
				return orig - addToLast.length;
			} else {
				return orig;
			}
		});
		if(lines.length > 2) {
			var _g1 = 0;
			var _g = lines.length - 1;
			while(_g1 < _g) {
				var i = _g1++;
				if(i % 2 == 1) {
					if(lines[i].charAt(lines[i].length - 1) != ".") {
						lines[i] += ".";
					}
					lines[i] += "..";
				}
			}
			this.game.focus(this);
		}
		this.currentLines = lines;
		this.currentLine = 0;
		this.drawCurrentLines(drawer);
	}
	,update: function() {
		if(this.keyboard.anyConfirm() || this.keyboard.anyBack()) {
			this.currentLine += 2;
			if(this.currentLine >= this.currentLines.length - 2) {
				this.game.focus(this.innerFocusable,false);
			}
			this.drawCurrentLines(this.game.drawer);
		}
	}
	,drawCurrentLines: function(drawer) {
		drawer.clearLines(0,2);
		if(this.currentLines.length > this.currentLine) {
			drawer.drawText(0,0,this.currentLines[this.currentLine]);
		}
		if(this.currentLines.length > this.currentLine + 1) {
			drawer.drawText(0,1,this.currentLines[this.currentLine + 1]);
		}
	}
	,__class__: ui_InfoDisplay
});
var ui_Menu = function(drawer,keyboard,world,game,innerFocusable,title,items,extraCloseKey) {
	this.scrollTop = 0;
	this.selectedItem = 0;
	this.drawer = drawer;
	Focusable.call(this,keyboard,world,game);
	this.title = title;
	this.items = items;
	this.extraCloseKey = extraCloseKey;
	this.innerFocusable = innerFocusable;
	this.info = new ui_InfoDisplay(keyboard,world,game,this);
	game.focus(this);
	this.draw();
};
ui_Menu.__name__ = true;
ui_Menu.__super__ = Focusable;
ui_Menu.prototype = $extend(Focusable.prototype,{
	close: function() {
		this.game.focus(this.innerFocusable);
	}
	,update: function() {
		if(this.keyboard.anyBack() || this.extraCloseKey != null && this.keyboard.pressed[this.extraCloseKey]) {
			this.close();
		} else {
			var down = this.keyboard.downKey() && !this.keyboard.upKey();
			var up = this.keyboard.upKey() && !this.keyboard.downKey();
			if(down && this.selectedItem < this.items.length - 1) {
				this.selectedItem += 1;
				this.draw();
			} else if(up && this.selectedItem > 0) {
				this.selectedItem -= 1;
				this.draw();
			} else if(this.keyboard.anyConfirm()) {
				if(this.items[this.selectedItem].onUse != null) {
					this.items[this.selectedItem].onUse();
				}
			}
		}
	}
	,draw: function() {
		this.drawer.clear();
		this.drawer.setMultiBackground(0,2,this.title.length,Drawer.colorToInt(Color.DarkGray));
		this.drawer.drawText(0,2,this.title);
		var menuHeight = 0;
		var selectedAt = 0;
		var upperLimit = 3;
		var _g1 = 0;
		var _g = this.items.length;
		while(_g1 < _g) {
			var i = _g1++;
			var item = this.items[i];
			if(this.selectedItem == i) {
				selectedAt = menuHeight;
			}
			menuHeight += item.getHeight(this.drawer);
		}
		var val = selectedAt - ((22 - upperLimit) / 2 | 0);
		var val2 = menuHeight - 22 + upperLimit;
		var maxVal = val2 > 0 ? val2 : 0;
		this.scrollTop = val < 0 ? 0 : val > maxVal ? maxVal : val;
		var yy = upperLimit - this.scrollTop;
		var _g11 = 0;
		var _g2 = this.items.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var item1 = this.items[i1];
			item1.draw(this.drawer,yy,upperLimit,22,this.selectedItem == i1);
			yy += item1.getHeight(this.drawer);
		}
	}
	,__class__: ui_Menu
});
var ui_MenuItem = function(text,extraDescription,onUse) {
	this.text = text;
	this.extraDescription = extraDescription;
	this.onUse = onUse;
};
ui_MenuItem.__name__ = true;
ui_MenuItem.prototype = {
	getHeight: function(drawer) {
		return 1 + (this.extraDescription == "" ? 0 : drawer.getAmountOfLines(2,0,this.extraDescription));
	}
	,draw: function(drawer,y,minY,maxY,selected) {
		if(y >= maxY) {
			return;
		}
		if(y >= minY) {
			if(selected) {
				drawer.drawText(0,y,">");
			}
			drawer.drawText(2,y,this.text);
		}
		var yy = y + 1;
		if(this.extraDescription != "") {
			var lines = drawer.splitIntoLines(2,y,this.extraDescription);
			var _g = 0;
			while(_g < lines.length) {
				var line = lines[_g];
				++_g;
				if(yy < maxY && yy >= minY) {
					drawer.drawText(2,yy,line,Drawer.colorToInt(Color.LightGray));
				}
				++yy;
			}
		}
	}
	,__class__: ui_MenuItem
};
var worldElements_WorldElement = function(world,position) {
	this.isCurrentlyVisible = false;
	this.seenByPlayer = false;
	this.world = world;
	this.set_position(position);
	this.character = "";
	this.color = Drawer.colorToInt(Color.White);
	this.init();
};
worldElements_WorldElement.__name__ = true;
worldElements_WorldElement.prototype = {
	get_isBlocking: function() {
		return false;
	}
	,get_isViewBlocking: function() {
		return false;
	}
	,get_isStatic: function() {
		return false;
	}
	,get_isEasierVisible: function() {
		return false;
	}
	,set_position: function(newPosition) {
		if(this.position != null) {
			this.world.removeFromElementsAtPosition(this,this.position);
		}
		this.position = newPosition;
		this.world.addToElementsAtPosition(this,newPosition);
		return this.position;
	}
	,init: function() {
	}
	,preUpdate: function() {
	}
	,postUpdate: function() {
	}
	,update: function(isExtra) {
		if(isExtra == null) {
			isExtra = false;
		}
	}
	,draw: function(drawer,notInView) {
		drawer.setWorldCharacter(this.position.x,this.position.y,this.character,this.color,notInView);
	}
	,getInfo: function() {
		return "You don't know what this is!";
	}
	,hasActionFor: function(triggeringWorldElement) {
		return false;
	}
	,performActionFor: function(triggeringWorldElement) {
	}
	,shouldRemove: function() {
		return false;
	}
	,isInterestingForPlayer: function(controllingOnly) {
		if(controllingOnly == null) {
			controllingOnly = true;
		}
		return false;
	}
	,__class__: worldElements_WorldElement
};
var worldElements_Floor = function(world,position) {
	worldElements_WorldElement.call(this,world,position);
};
worldElements_Floor.__name__ = true;
worldElements_Floor.__super__ = worldElements_WorldElement;
worldElements_Floor.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return false;
	}
	,get_isViewBlocking: function() {
		return false;
	}
	,get_isStatic: function() {
		return true;
	}
	,get_isEasierVisible: function() {
		return true;
	}
	,init: function() {
		this.color = 2105376;
	}
	,draw: function(drawer,notInView) {
		drawer.setWorldWall(this.position.x,this.position.y,this.color,notInView);
	}
	,getInfo: function() {
		return "";
	}
	,__class__: worldElements_Floor
});
var worldElements_PlayerBody = function(world,position) {
	worldElements_WorldElement.call(this,world,position);
};
worldElements_PlayerBody.__name__ = true;
worldElements_PlayerBody.__super__ = worldElements_WorldElement;
worldElements_PlayerBody.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return true;
	}
	,get_isViewBlocking: function() {
		return true;
	}
	,init: function() {
		worldElements_WorldElement.prototype.init.call(this);
		this.color = Drawer.colorToInt(Color.DarkLightBlue);
		this.character = "@";
	}
	,getInfo: function() {
		return "Your body!";
	}
	,__class__: worldElements_PlayerBody
});
var worldElements_Wall = function(world,position) {
	worldElements_WorldElement.call(this,world,position);
};
worldElements_Wall.__name__ = true;
worldElements_Wall.__super__ = worldElements_WorldElement;
worldElements_Wall.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return true;
	}
	,get_isViewBlocking: function() {
		return true;
	}
	,get_isStatic: function() {
		return true;
	}
	,get_isEasierVisible: function() {
		return true;
	}
	,draw: function(drawer,notInView) {
		drawer.setWorldWall(this.position.x,this.position.y,this.color,notInView);
	}
	,getInfo: function() {
		return "A wall.";
	}
	,__class__: worldElements_Wall
});
var worldElements_creatures_Creature = function(world,position) {
	this.wanderTo = null;
	this.aggressiveNearDistance = 2;
	this.aggressiveToPlayerIfNear = false;
	this.aggressiveToPlayer = false;
	this.followTimeWithoutSee = 3;
	this.lastSeenCreature = new haxe_ds_ObjectMap();
	this.speedPoints = 0;
	this.attackedBy = [];
	this.creatureFullAttackVerb = "bite";
	this.creatureAttackVerb = "bit";
	this.creatureTypeAorAn = "a";
	this.creatureTypeName = "creature";
	this.hasMoved = false;
	worldElements_WorldElement.call(this,world,position);
};
worldElements_creatures_Creature.__name__ = true;
worldElements_creatures_Creature.__super__ = worldElements_WorldElement;
worldElements_creatures_Creature.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return true;
	}
	,get_statusModifiers: function() {
		var mods = [];
		var _g = 0;
		var _g1 = this.statusEffects;
		while(_g < _g1.length) {
			var se = _g1[_g];
			++_g;
			mods.push(se);
		}
		return mods;
	}
	,init: function() {
		this.movement = new worldElements_creatures_movement_BasicMovement();
		this.originalMovement = this.movement;
		this.stats = new worldElements_creatures_stats_CreatureStats(1,1);
		this.basicAttack = new worldElements_creatures_actions_DirectionalAttack(this);
		this.actions = [];
		this.actions.push(this.basicAttack);
		this.attackedBy = [];
		this.statusEffects = [];
	}
	,preUpdate: function() {
		this.hasMoved = false;
	}
	,update: function(isExtra) {
		if(isExtra == null) {
			isExtra = false;
		}
		worldElements_WorldElement.prototype.update.call(this);
		if(!this.hasMoved) {
			if(!isExtra) {
				this.speedPoints += this.stats.speed;
			}
			var playerSpeed = this.world.player.controllingBody.stats.speed;
			if(this.speedPoints >= playerSpeed) {
				this.movement.move(this.world,this);
				this.hasMoved = true;
				this.speedPoints -= playerSpeed;
				if(this.speedPoints >= playerSpeed) {
					this.world.requestExtraUpdate(this);
				}
			}
		}
	}
	,postUpdate: function() {
		var i = this.statusEffects.length;
		while(--i >= 0) {
			var statusEffect = this.statusEffects[i];
			statusEffect.onTurn();
			if(statusEffect.ended) {
				this.statusEffects.splice(i,1);
			}
		}
		var creature = this.lastSeenCreature.keys();
		while(creature.hasNext()) {
			var creature1 = creature.next();
			var _g = creature1;
			var _g1 = this.lastSeenCreature;
			var v = _g1.h[_g.__id__] + 1;
			_g1.set(_g,v);
		}
		this.stats.timeToNextAPRegen -= 1;
		if(this.stats.ap == this.stats.maxAP) {
			this.stats.timeToNextAPRegen = this.stats.apRegen;
		}
		if(this.stats.timeToNextAPRegen <= 0) {
			this.stats.gainAP(1);
			this.stats.timeToNextAPRegen = this.stats.apRegen;
		}
		this.stats.timeToNextHPRegen -= 1;
		if(this.stats.hp == this.stats.maxHP) {
			this.stats.timeToNextHPRegen = this.stats.hpRegen;
		}
		if(this.stats.timeToNextHPRegen <= 0) {
			this.stats.gainHP(1);
			this.stats.timeToNextHPRegen = this.stats.hpRegen;
		}
	}
	,getInfo: function() {
		var pre = "";
		var post = "";
		if(this.world.player.ownBody == this && this.world.player.controllingBody == this) {
			pre = "You, ";
		} else if(this.world.player.controllingBody == this) {
			post = ", controlled by you";
		} else if(this.world.player.ownBody == this) {
			pre = "Your own body, ";
		}
		var info = this.stats.getInfo();
		if(this.statusEffects.length > 0) {
			var _g = 0;
			var _g1 = this.statusEffects;
			while(_g < _g1.length) {
				var statusEffect = _g1[_g];
				++_g;
				if(info != "") {
					info += "; ";
				}
				info += statusEffect.name;
			}
		}
		var str = pre + ("" + this.creatureTypeAorAn + " " + this.creatureTypeName + post + " - " + info);
		if(str.length == 0) {
			return str;
		} else {
			return str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null);
		}
	}
	,hasActionFor: function(triggeringWorldElement) {
		if(js_Boot.__instanceof(triggeringWorldElement,worldElements_creatures_Creature)) {
			return true;
		}
		return false;
	}
	,performActionFor: function(triggeringWorldElement) {
		if(js_Boot.__instanceof(triggeringWorldElement,worldElements_creatures_Creature)) {
			triggeringWorldElement.attack(this);
		}
	}
	,attack: function(what) {
		this.basicAttack.useOnElement(what);
	}
	,shouldRemove: function() {
		if(this.stats.hp <= 0) {
			if(this.world.player.ownBody == this && this.world.player.controllingBody != this) {
				this.world.info.addInfo("While you were mind controlling, you have been defeated!".length == 0 ? "While you were mind controlling, you have been defeated!" : "While you were mind controlling, you have been defeated!".charAt(0).toUpperCase() + HxOverrides.substr("While you were mind controlling, you have been defeated!",1,null));
			} else {
				var tmp = this.world.info;
				var str = "" + this.getNameToUse() + " " + this.getHaveOrHas() + " been defeated.";
				tmp.addInfo(str.length == 0 ? str : str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null));
			}
			return true;
		}
		return false;
	}
	,isInterestingForPlayer: function(controllingOnly) {
		if(controllingOnly == null) {
			controllingOnly = true;
		}
		if(!(!controllingOnly && this.world.player.ownBody == this)) {
			return this.world.player.controllingBody == this;
		} else {
			return true;
		}
	}
	,getNameToUse: function() {
		if(this.world.player.controllingBody == this) {
			return "you";
		} else {
			return "the " + this.creatureTypeName;
		}
	}
	,getReferenceToUse: function(itself,object) {
		if(object == null) {
			object = false;
		}
		if(itself == null) {
			itself = false;
		}
		if(this.world.player.controllingBody == this) {
			if(itself) {
				return "yourself";
			} else {
				return "you";
			}
		} else if(itself) {
			return "itself";
		} else {
			return "it";
		}
	}
	,getAttackVerb: function() {
		return this.creatureAttackVerb;
	}
	,getWereOrWas: function() {
		if(this.world.player.controllingBody == this) {
			return "were";
		} else {
			return "was";
		}
	}
	,getHaveOrHas: function() {
		if(this.world.player.controllingBody == this) {
			return "have";
		} else {
			return "has";
		}
	}
	,addStatusEffect: function(statusEffect) {
		this.statusEffects.push(statusEffect);
	}
	,makesCreatureAggressive: function(creature) {
		return common_ArrayExtensions.any(this.get_statusModifiers(),function(sm) {
			return sm.makesCreatureAggressive(creature);
		});
	}
	,__class__: worldElements_creatures_Creature
});
var worldElements_creatures_Goblin = function(world,position) {
	worldElements_creatures_Creature.call(this,world,position);
};
worldElements_creatures_Goblin.__name__ = true;
worldElements_creatures_Goblin.__super__ = worldElements_creatures_Creature;
worldElements_creatures_Goblin.prototype = $extend(worldElements_creatures_Creature.prototype,{
	init: function() {
		worldElements_creatures_Creature.prototype.init.call(this);
		this.color = 8490792;
		this.character = "g";
		this.creatureTypeName = "goblin";
		this.stats.setMaxHP(8);
		this.stats.setMaxAP(3);
		this.stats.setAttack(2);
		this.stats.speed = 100;
		this.actions.push(new worldElements_creatures_actions_AfflictStatusEffect(this,worldElements_creatures_statusEffects_SplitOnByGoblin,function(c) {
			return new worldElements_creatures_statusEffects_SplitOnByGoblin(c);
		},"{subject} spit on {object}, making all goblins aggressive to {shortObject}!",3,"Spit","Spit on an enemy next to you, making all goblins aggressive to it."));
		this.creatureAttackVerb = "hit";
		this.creatureFullAttackVerb = "hit";
		this.aggressiveToPlayerIfNear = true;
	}
	,__class__: worldElements_creatures_Goblin
});
var worldElements_creatures_Human = function(world,position) {
	worldElements_creatures_Creature.call(this,world,position);
};
worldElements_creatures_Human.__name__ = true;
worldElements_creatures_Human.__super__ = worldElements_creatures_Creature;
worldElements_creatures_Human.prototype = $extend(worldElements_creatures_Creature.prototype,{
	init: function() {
		worldElements_creatures_Creature.prototype.init.call(this);
		this.color = Drawer.colorToInt(Color.LightBlue);
		this.character = "@";
		this.creatureTypeName = "human";
		this.stats.setMaxHP(10);
		this.stats.setMaxAP(10);
		this.stats.setAttack(3);
		this.stats.setCritChance(0.05);
		this.creatureAttackVerb = "hit";
		this.creatureFullAttackVerb = "hit";
	}
	,__class__: worldElements_creatures_Human
});
var worldElements_creatures_ManeatingPlant = function(world,position) {
	worldElements_creatures_Creature.call(this,world,position);
};
worldElements_creatures_ManeatingPlant.__name__ = true;
worldElements_creatures_ManeatingPlant.__super__ = worldElements_creatures_Creature;
worldElements_creatures_ManeatingPlant.prototype = $extend(worldElements_creatures_Creature.prototype,{
	init: function() {
		worldElements_creatures_Creature.prototype.init.call(this);
		this.color = 6356832;
		this.character = "p";
		this.creatureTypeName = "man-eating plant";
		this.stats.setMaxHP(7);
		this.stats.setMaxAP(3);
		this.stats.setAttack(3);
		this.stats.speed = 100;
		this.creatureAttackVerb = "grabbed";
		this.creatureFullAttackVerb = "grab";
		this.aggressiveToPlayerIfNear = true;
		this.aggressiveNearDistance = 1;
		this.movement = new worldElements_creatures_movement_StillMovement();
	}
	,__class__: worldElements_creatures_ManeatingPlant
});
var worldElements_creatures_Rat = function(world,position) {
	worldElements_creatures_Creature.call(this,world,position);
};
worldElements_creatures_Rat.__name__ = true;
worldElements_creatures_Rat.__super__ = worldElements_creatures_Creature;
worldElements_creatures_Rat.prototype = $extend(worldElements_creatures_Creature.prototype,{
	init: function() {
		worldElements_creatures_Creature.prototype.init.call(this);
		this.color = 14259306;
		this.character = "r";
		this.creatureTypeName = "rat";
		this.stats.setMaxHP(5);
		this.stats.setMaxAP(1);
		this.stats.setAttack(1);
		this.stats.speed = 150;
		this.actions.push(new worldElements_creatures_actions_AfflictStatusEffect(this,worldElements_creatures_statusEffects_Poison,function(c) {
			return new worldElements_creatures_statusEffects_Poison(c);
		},"{subject} poisoned {object}!",1,"Rat Poison","Inject poison into an enemy next to you."));
	}
	,__class__: worldElements_creatures_Rat
});
var worldElements_creatures_actions_CreatureAction = function(creature) {
	this.abilityDescription = "";
	this.abilityName = "";
	this.creature = creature;
};
worldElements_creatures_actions_CreatureAction.__name__ = true;
worldElements_creatures_actions_CreatureAction.prototype = {
	get_actionPoints: function() {
		return 0;
	}
	,canUse: function() {
		return false;
	}
	,'use': function() {
	}
	,tryPossibleParameters: function(targets) {
		return false;
	}
	,getPriority: function() {
		return this.get_actionPoints();
	}
	,__class__: worldElements_creatures_actions_CreatureAction
};
var worldElements_creatures_actions_DirectionAction = function(creature) {
	this.direction = null;
	worldElements_creatures_actions_CreatureAction.call(this,creature);
};
worldElements_creatures_actions_DirectionAction.__name__ = true;
worldElements_creatures_actions_DirectionAction.__super__ = worldElements_creatures_actions_CreatureAction;
worldElements_creatures_actions_DirectionAction.prototype = $extend(worldElements_creatures_actions_CreatureAction.prototype,{
	setParameter: function(direction) {
		this.direction = direction;
	}
	,canUse: function() {
		var _gthis = this;
		return common_ArrayExtensions.any(this.elementsInDirection(),function(elem) {
			return _gthis.canUseOnElement(elem);
		});
	}
	,canUseOnCreatureFrom: function(creatures) {
		return this.canUseOnAnyCreatureFromElements(this.elementsInDirection(),creatures);
	}
	,canUseOnAnyCreatureFromElements: function(elements,creatures) {
		var _gthis = this;
		return common_ArrayExtensions.any(elements,function(elem) {
			if(js_Boot.__instanceof(elem,worldElements_creatures_Creature) && common_ArrayExtensions.contains(creatures,elem)) {
				return _gthis.canUseOnElement(elem);
			} else {
				return false;
			}
		});
	}
	,tryPossibleParameters: function(targets) {
		var options = [common_Direction.Left,common_Direction.Right,common_Direction.Up,common_Direction.Down];
		var _g = 0;
		while(_g < options.length) {
			var option = options[_g];
			++_g;
			this.setParameter(option);
			if(this.canUseOnCreatureFrom(targets)) {
				this["use"]();
				return true;
			}
		}
		return false;
	}
	,canUseOnElement: function(elementHere) {
		return false;
	}
	,'use': function() {
		var elems = this.elementsInDirection();
		var _g = 0;
		while(_g < elems.length) {
			var elem = elems[_g];
			++_g;
			if(this.canUseOnElement(elem)) {
				this.useOnElement(elem);
				break;
			}
		}
	}
	,useOnElement: function(elementHere) {
	}
	,elementsInDirection: function() {
		var positionHere = this.creature.world.positionInDirection(this.creature.position,this.direction);
		if(positionHere != null) {
			return this.creature.world.elementsAtPosition(positionHere);
		}
		return [];
	}
	,__class__: worldElements_creatures_actions_DirectionAction
});
var worldElements_creatures_actions_AfflictStatusEffect = function(creature,statusEffectType,makeStatusEffect,onAfflictText,ap,abilityName,abilityDescription) {
	worldElements_creatures_actions_DirectionAction.call(this,creature);
	this.statusEffectType = statusEffectType;
	this.makeStatusEffect = makeStatusEffect;
	this.onAfflictText = onAfflictText;
	this.ap = ap;
	this.abilityName = abilityName;
	this.abilityDescription = abilityDescription;
};
worldElements_creatures_actions_AfflictStatusEffect.__name__ = true;
worldElements_creatures_actions_AfflictStatusEffect.__super__ = worldElements_creatures_actions_DirectionAction;
worldElements_creatures_actions_AfflictStatusEffect.prototype = $extend(worldElements_creatures_actions_DirectionAction.prototype,{
	get_actionPoints: function() {
		return this.ap;
	}
	,canUseOnElement: function(elementHere) {
		var _gthis = this;
		if(js_Boot.__instanceof(elementHere,worldElements_creatures_Creature)) {
			return !common_ArrayExtensions.any(elementHere.statusEffects,function(se) {
				return js_Boot.__instanceof(se,_gthis.statusEffectType);
			});
		} else {
			return false;
		}
	}
	,useOnElement: function(elementHere) {
		var creatureHere = elementHere;
		var se = this.makeStatusEffect(creatureHere);
		creatureHere.addStatusEffect(se);
		if(se.negative) {
			worldElements_creatures_actions_AttackCalculator.attackStandardResults(this.creature,creatureHere);
		}
		if(this.creature.isInterestingForPlayer() || creatureHere.isInterestingForPlayer()) {
			var tmp = this.creature.world.info;
			var str = StringTools.replace(StringTools.replace(StringTools.replace(this.onAfflictText,"{subject}",this.creature.getNameToUse()),"{object}",creatureHere.getNameToUse()),"{shortObject}",creatureHere.getReferenceToUse(false,true));
			tmp.addInfo(str.length == 0 ? str : str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null));
		}
	}
	,__class__: worldElements_creatures_actions_AfflictStatusEffect
});
var worldElements_creatures_actions_AttackResult = { __ename__ : true, __constructs__ : ["Damage","Critical","Block"] };
worldElements_creatures_actions_AttackResult.Damage = function(damage) { var $x = ["Damage",0,damage]; $x.__enum__ = worldElements_creatures_actions_AttackResult; $x.toString = $estr; return $x; };
worldElements_creatures_actions_AttackResult.Critical = function(damage) { var $x = ["Critical",1,damage]; $x.__enum__ = worldElements_creatures_actions_AttackResult; $x.toString = $estr; return $x; };
worldElements_creatures_actions_AttackResult.Block = ["Block",2];
worldElements_creatures_actions_AttackResult.Block.toString = $estr;
worldElements_creatures_actions_AttackResult.Block.__enum__ = worldElements_creatures_actions_AttackResult;
var worldElements_creatures_actions_AttackCalculator = function() { };
worldElements_creatures_actions_AttackCalculator.__name__ = true;
worldElements_creatures_actions_AttackCalculator.basicAttack = function(attackingCreature,attackedCreature) {
	var attackPart = attackingCreature.stats.attack;
	attackPart = common_Random.getInt(Math.ceil(attackPart / 2),attackPart + 1);
	var defencePart = attackedCreature.stats.defence;
	var isCritical = false;
	if(common_Random.getFloat() < attackingCreature.stats.critChance) {
		isCritical = true;
		attackPart += Math.ceil(attackingCreature.stats.attack * 0.67);
		var val1 = attackPart - 1;
		if(defencePart < val1) {
			defencePart = defencePart;
		} else {
			defencePart = val1;
		}
	}
	var damage = attackPart - defencePart;
	attackedCreature.stats.hp -= damage;
	var result;
	if(damage > 0) {
		if(isCritical) {
			result = worldElements_creatures_actions_AttackResult.Critical(damage);
		} else {
			result = worldElements_creatures_actions_AttackResult.Damage(damage);
		}
	} else if(defencePart > 0) {
		result = worldElements_creatures_actions_AttackResult.Block;
	} else {
		result = worldElements_creatures_actions_AttackResult.Damage(0);
	}
	worldElements_creatures_actions_AttackCalculator.attackStandardResults(attackingCreature,attackedCreature);
	return result;
};
worldElements_creatures_actions_AttackCalculator.attackStandardResults = function(attackingCreature,attackedCreature) {
	if(!common_ArrayExtensions.contains(attackedCreature.attackedBy,attackingCreature)) {
		attackedCreature.attackedBy.push(attackingCreature);
	}
};
var worldElements_creatures_actions_Dash = function(creature) {
	worldElements_creatures_actions_DirectionAction.call(this,creature);
	this.abilityName = "Dash";
	this.abilityDescription = "Move up to three spaces in one direction. If you hit an enemy, attack it.";
};
worldElements_creatures_actions_Dash.__name__ = true;
worldElements_creatures_actions_Dash.__super__ = worldElements_creatures_actions_DirectionAction;
worldElements_creatures_actions_Dash.prototype = $extend(worldElements_creatures_actions_DirectionAction.prototype,{
	get_actionPoints: function() {
		return 2;
	}
	,canUse: function() {
		return this.creature.world.noBlockingElementsAt(this.creature.world.positionInDirection(this.creature.position,this.direction),false);
	}
	,canUseOnElement: function(elementHere) {
		return true;
	}
	,canUseOnCreatureFrom: function(creatures) {
		if(!this.canUse()) {
			return false;
		}
		var pos = this.creature.position;
		var _g = 0;
		while(_g < 4) {
			var i = _g++;
			pos = this.creature.world.positionInDirection(pos,this.direction);
			if(this.canUseOnAnyCreatureFromElements(this.creature.world.elementsAtPosition(pos),creatures)) {
				return true;
			}
			if(!this.creature.world.noBlockingElementsAt(pos,false)) {
				break;
			}
		}
		return false;
	}
	,'use': function() {
		var pos = this.creature.position;
		var moveToPos = this.creature.position;
		var attacked = false;
		var _g = 0;
		while(_g < 4) {
			var i = _g++;
			pos = this.creature.world.positionInDirection(pos,this.direction);
			var elems = this.creature.world.elementsAtPosition(pos);
			var _g1 = 0;
			while(_g1 < elems.length) {
				var elem = elems[_g1];
				++_g1;
				if(js_Boot.__instanceof(elem,worldElements_creatures_Creature)) {
					var creatureHere = elem;
					var result = worldElements_creatures_actions_AttackCalculator.basicAttack(this.creature,creatureHere);
					if(this.creature.isInterestingForPlayer() || creatureHere.isInterestingForPlayer()) {
						var text;
						switch(result[1]) {
						case 0:
							var damage = result[2];
							var str = "" + this.creature.getNameToUse() + " dashed into " + creatureHere.getNameToUse() + " for " + damage + " damage.";
							if(str.length == 0) {
								text = str;
							} else {
								text = str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null);
							}
							break;
						case 1:
							var damage1 = result[2];
							var str1 = "" + this.creature.getNameToUse() + " dashed into " + creatureHere.getNameToUse() + ". It's a critical hit for " + damage1 + " damage!";
							if(str1.length == 0) {
								text = str1;
							} else {
								text = str1.charAt(0).toUpperCase() + HxOverrides.substr(str1,1,null);
							}
							break;
						case 2:
							var str2 = "" + this.creature.getNameToUse() + " tried to dash into " + creatureHere.getNameToUse() + ", but " + creatureHere.getReferenceToUse() + " defended " + creatureHere.getReferenceToUse(true) + ".";
							if(str2.length == 0) {
								text = str2;
							} else {
								text = str2.charAt(0).toUpperCase() + HxOverrides.substr(str2,1,null);
							}
							break;
						}
						this.creature.world.info.addInfo(text);
					}
					attacked = true;
					break;
				}
			}
			if(attacked) {
				break;
			}
			if(!this.creature.world.noBlockingElementsAt(pos,false)) {
				break;
			}
			if(i != 3) {
				moveToPos = pos;
			}
		}
		this.creature.set_position(moveToPos);
	}
	,__class__: worldElements_creatures_actions_Dash
});
var worldElements_creatures_actions_DirectionalAttack = function(creature) {
	worldElements_creatures_actions_DirectionAction.call(this,creature);
};
worldElements_creatures_actions_DirectionalAttack.__name__ = true;
worldElements_creatures_actions_DirectionalAttack.__super__ = worldElements_creatures_actions_DirectionAction;
worldElements_creatures_actions_DirectionalAttack.prototype = $extend(worldElements_creatures_actions_DirectionAction.prototype,{
	canUseOnElement: function(elementHere) {
		return js_Boot.__instanceof(elementHere,worldElements_creatures_Creature);
	}
	,useOnElement: function(elementHere) {
		var creatureHere = elementHere;
		var result = worldElements_creatures_actions_AttackCalculator.basicAttack(this.creature,creatureHere);
		if(this.creature.isInterestingForPlayer() || elementHere.isInterestingForPlayer()) {
			var text;
			switch(result[1]) {
			case 0:
				var damage = result[2];
				var str = "" + this.creature.getNameToUse() + " " + this.creature.getAttackVerb() + " " + creatureHere.getNameToUse() + " for " + damage + " damage.";
				if(str.length == 0) {
					text = str;
				} else {
					text = str.charAt(0).toUpperCase() + HxOverrides.substr(str,1,null);
				}
				break;
			case 1:
				var damage1 = result[2];
				var str1 = "" + this.creature.getNameToUse() + " " + this.creature.getAttackVerb() + " " + creatureHere.getNameToUse() + ". It's a critical hit for " + damage1 + " damage!";
				if(str1.length == 0) {
					text = str1;
				} else {
					text = str1.charAt(0).toUpperCase() + HxOverrides.substr(str1,1,null);
				}
				break;
			case 2:
				var str2 = "" + this.creature.getNameToUse() + " tried to " + this.creature.creatureFullAttackVerb + " " + creatureHere.getNameToUse() + ", but " + creatureHere.getReferenceToUse() + " defended " + creatureHere.getReferenceToUse(true) + ".";
				if(str2.length == 0) {
					text = str2;
				} else {
					text = str2.charAt(0).toUpperCase() + HxOverrides.substr(str2,1,null);
				}
				break;
			}
			this.creature.world.info.addInfo(text);
		}
	}
	,__class__: worldElements_creatures_actions_DirectionalAttack
});
var worldElements_creatures_actions_StopTakeOver = function(creature) {
	worldElements_creatures_actions_CreatureAction.call(this,creature);
	this.abilityName = "Stop Mind Control";
	this.abilityDescription = "Stop mind controlling this creature.";
};
worldElements_creatures_actions_StopTakeOver.__name__ = true;
worldElements_creatures_actions_StopTakeOver.__super__ = worldElements_creatures_actions_CreatureAction;
worldElements_creatures_actions_StopTakeOver.prototype = $extend(worldElements_creatures_actions_CreatureAction.prototype,{
	get_actionPoints: function() {
		return 0;
	}
	,canUse: function() {
		return true;
	}
	,'use': function() {
		this.creature.world.info.addInfo("You stopped mind controlling and found yourself back in your own body.");
		this.creature.world.player.stopTakeover();
	}
	,__class__: worldElements_creatures_actions_StopTakeOver
});
var worldElements_creatures_actions_TakeOverEnemy = function(creature) {
	worldElements_creatures_actions_DirectionAction.call(this,creature);
	this.abilityName = "Mind Control";
	this.abilityDescription = "Take over an enemy next to you. Make sure you're at least somewhat safe, as you won't be able to move your own body until you end the mind control.";
};
worldElements_creatures_actions_TakeOverEnemy.__name__ = true;
worldElements_creatures_actions_TakeOverEnemy.__super__ = worldElements_creatures_actions_DirectionAction;
worldElements_creatures_actions_TakeOverEnemy.prototype = $extend(worldElements_creatures_actions_DirectionAction.prototype,{
	get_actionPoints: function() {
		return 5;
	}
	,canUseOnElement: function(elementHere) {
		return js_Boot.__instanceof(elementHere,worldElements_creatures_Creature);
	}
	,useOnElement: function(elementHere) {
		var creatureHere = elementHere;
		this.creature.world.info.addInfo("You started mind controlling " + creatureHere.getNameToUse() + ".");
		this.creature.world.player.controllingBody = creatureHere;
		this.creature.world.player.afterTakeover();
	}
	,__class__: worldElements_creatures_actions_TakeOverEnemy
});
var worldElements_creatures_movement_Movement = function() {
	this.autoMove = true;
};
worldElements_creatures_movement_Movement.__name__ = true;
worldElements_creatures_movement_Movement.prototype = {
	canMove: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			var elementsHere = world.elementsAtPosition(newPosition);
			if(!this.isBlockingElementIn(world,elementsHere)) {
				return true;
			}
			if(common_ArrayExtensions.any(elementsHere,function(e) {
				return e.hasActionFor(creature);
			})) {
				return true;
			}
		}
		return false;
	}
	,isBlockingElementIn: function(world,elementsHere) {
		if(!common_ArrayExtensions.any(elementsHere,function(e) {
			return e.get_isBlocking();
		})) {
			return false;
		}
		return true;
	}
	,move: function(world,creature) {
	}
	,moveInDirection: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			var elementsHere = world.elementsAtPosition(newPosition);
			if(!this.isBlockingElementIn(world,elementsHere)) {
				creature.set_position(newPosition);
			}
			var _g = 0;
			while(_g < elementsHere.length) {
				var elem = elementsHere[_g];
				++_g;
				if(elem != creature && elem.hasActionFor(creature)) {
					elem.performActionFor(creature);
					break;
				}
			}
		}
	}
	,__class__: worldElements_creatures_movement_Movement
};
var worldElements_creatures_movement_BasicMovement = function() {
	worldElements_creatures_movement_Movement.call(this);
};
worldElements_creatures_movement_BasicMovement.__name__ = true;
worldElements_creatures_movement_BasicMovement.__super__ = worldElements_creatures_movement_Movement;
worldElements_creatures_movement_BasicMovement.prototype = $extend(worldElements_creatures_movement_Movement.prototype,{
	getAggresiveTo: function(world,creature) {
		var aggressiveToCreatures = creature.attackedBy.slice();
		var tmp;
		var tmp1;
		if(!creature.aggressiveToPlayer) {
			if(creature.aggressiveToPlayerIfNear) {
				var _this = creature.position;
				var otherPoint = world.player.ownBody.position;
				tmp1 = Math.abs(_this.x - otherPoint.x) + Math.abs(_this.y - otherPoint.y) <= creature.aggressiveNearDistance;
			} else {
				tmp1 = false;
			}
		} else {
			tmp1 = true;
		}
		if(tmp1) {
			tmp = !common_ArrayExtensions.contains(aggressiveToCreatures,world.player.ownBody);
		} else {
			tmp = false;
		}
		if(tmp) {
			aggressiveToCreatures.push(world.player.ownBody);
		}
		var _g = 0;
		var _g1 = world.get_creatures();
		while(_g < _g1.length) {
			var worldCreature = _g1[_g];
			++_g;
			if(common_ArrayExtensions.contains(aggressiveToCreatures,worldCreature)) {
				continue;
			}
			if(worldCreature.makesCreatureAggressive(creature)) {
				aggressiveToCreatures.push(worldCreature);
			}
		}
		return aggressiveToCreatures;
	}
	,move: function(world,creature) {
		if(!this.autoMove) {
			return;
		}
		var aggressiveToCreatures = this.getAggresiveTo(world,creature);
		var isAggressiveToThis = function(elem) {
			if(js_Boot.__instanceof(elem,worldElements_creatures_Creature)) {
				return common_ArrayExtensions.contains(aggressiveToCreatures,elem);
			} else {
				return false;
			}
		};
		var toTargets = world.pathfinder.find(creature.position,function(pos) {
			return common_ArrayExtensions.any(world.elementsAtPosition(pos),isAggressiveToThis);
		},true);
		var nearestTarget = null;
		var nearestTargetInfo = null;
		var nearestTargetDistance = 1000000;
		var _g = 0;
		while(_g < toTargets.length) {
			var toTarget = toTargets[_g];
			++_g;
			var target = world.elementsAtPosition(toTarget.point).filter(isAggressiveToThis)[0];
			var canSee = world.pathfinder.isVisible(creature.position,target.position);
			if(canSee) {
				creature.lastSeenCreature.set(target,0);
			}
			if(creature.lastSeenCreature.h[target.__id__] <= creature.followTimeWithoutSee) {
				nearestTarget = target;
				nearestTargetInfo = toTarget;
				nearestTargetDistance = toTarget.distance;
			}
		}
		if(nearestTarget != null) {
			if(!this.canUseAnyAbility(creature,aggressiveToCreatures)) {
				this.moveInDirection(world,creature,nearestTargetInfo.inDirection);
			}
		} else {
			if(creature.wanderTo == null) {
				var wanderToOptions = world.pathfinder.find(creature.position,function(p) {
					return world.noBlockingElementsAt(p,false);
				},true);
				if(wanderToOptions.length > 0) {
					creature.wanderTo = common_Random.fromArray(wanderToOptions).point;
				}
			}
			if(creature.wanderTo != null) {
				var wanderInfo = world.pathfinder.find(creature.position,function(p1) {
					var otherPoint = creature.wanderTo;
					if(p1.x == otherPoint.x && p1.y == otherPoint.y) {
						return world.noBlockingElementsAt(p1,false);
					} else {
						return false;
					}
				},false);
				if(wanderInfo.length > 0) {
					this.moveInDirection(world,creature,wanderInfo[0].inDirection);
					if(creature.position == creature.wanderTo) {
						creature.wanderTo = null;
					}
				} else {
					creature.wanderTo = null;
				}
			}
		}
	}
	,canUseAnyAbility: function(creature,aggressiveToCreatures) {
		var sortedActions = creature.actions.slice();
		sortedActions.sort(function(x,y) {
			return y.getPriority() - x.getPriority();
		});
		var _g = 0;
		while(_g < sortedActions.length) {
			var ability = sortedActions[_g];
			++_g;
			if(creature.stats.ap >= ability.get_actionPoints() && ability.getPriority() >= 0) {
				if(ability.tryPossibleParameters(aggressiveToCreatures)) {
					creature.stats.ap -= ability.get_actionPoints();
					return true;
				}
			}
		}
		return false;
	}
	,__class__: worldElements_creatures_movement_BasicMovement
});
var worldElements_creatures_movement_StillMovement = function() {
	worldElements_creatures_movement_BasicMovement.call(this);
};
worldElements_creatures_movement_StillMovement.__name__ = true;
worldElements_creatures_movement_StillMovement.__super__ = worldElements_creatures_movement_BasicMovement;
worldElements_creatures_movement_StillMovement.prototype = $extend(worldElements_creatures_movement_BasicMovement.prototype,{
	canMove: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			var elementsHere = world.elementsAtPosition(newPosition);
			if(common_ArrayExtensions.any(elementsHere,function(e) {
				return e.hasActionFor(creature);
			})) {
				return true;
			}
		}
		return false;
	}
	,move: function(world,creature) {
		if(!this.autoMove) {
			return;
		}
		var aggressiveToCreatures = this.getAggresiveTo(world,creature);
		this.canUseAnyAbility(creature,aggressiveToCreatures);
	}
	,moveInDirection: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			var elementsHere = world.elementsAtPosition(newPosition);
			var _g = 0;
			while(_g < elementsHere.length) {
				var elem = elementsHere[_g];
				++_g;
				if(elem != creature && elem.hasActionFor(creature)) {
					elem.performActionFor(creature);
					break;
				}
			}
		}
	}
	,__class__: worldElements_creatures_movement_StillMovement
});
var worldElements_creatures_stats_CreatureStats = function(hp,ap,attack,defence) {
	if(defence == null) {
		defence = 0;
	}
	if(attack == null) {
		attack = 0;
	}
	this.maxHP = hp;
	this.maxAP = ap;
	this.attack = attack;
	this.defence = defence;
	this.hp = hp;
	this.ap = ap;
	this.speed = 100;
	this.apRegen = 10;
	this.hpRegen = 10;
	this.timeToNextAPRegen = 10;
	this.timeToNextHPRegen = 10;
	this.critChance = 0;
};
worldElements_creatures_stats_CreatureStats.__name__ = true;
worldElements_creatures_stats_CreatureStats.prototype = {
	getInfo: function() {
		return "HP: " + this.hp + "/" + this.maxHP + "; AP: " + this.ap + "/" + this.maxAP;
	}
	,setMaxHP: function(newMaxHP) {
		var diff = newMaxHP - this.maxHP;
		this.maxHP = newMaxHP;
		this.hp += diff;
	}
	,setMaxAP: function(newMaxAP) {
		var diff = newMaxAP - this.maxAP;
		this.maxAP = newMaxAP;
		this.ap += diff;
	}
	,setAttack: function(attack) {
		this.attack = attack;
	}
	,gainHP: function(gain) {
		var val1 = this.hp + gain;
		var val2 = this.maxHP;
		this.hp = val2 < val1 ? val2 : val1;
	}
	,gainAP: function(gain) {
		var val1 = this.ap + gain;
		var val2 = this.maxAP;
		this.ap = val2 < val1 ? val2 : val1;
	}
	,setCritChance: function(chance) {
		this.critChance = chance;
	}
	,__class__: worldElements_creatures_stats_CreatureStats
};
var worldElements_creatures_statusModifiers_StatusModifier = function(creature) {
	this.creature = creature;
	this.init();
};
worldElements_creatures_statusModifiers_StatusModifier.__name__ = true;
worldElements_creatures_statusModifiers_StatusModifier.prototype = {
	init: function() {
	}
	,onTurn: function() {
	}
	,makesCreatureAggressive: function(creature) {
		return false;
	}
	,__class__: worldElements_creatures_statusModifiers_StatusModifier
};
var worldElements_creatures_statusEffects_StatusEffect = function(creature) {
	this.negative = true;
	this.ended = false;
	this.name = "";
	worldElements_creatures_statusModifiers_StatusModifier.call(this,creature);
};
worldElements_creatures_statusEffects_StatusEffect.__name__ = true;
worldElements_creatures_statusEffects_StatusEffect.__super__ = worldElements_creatures_statusModifiers_StatusModifier;
worldElements_creatures_statusEffects_StatusEffect.prototype = $extend(worldElements_creatures_statusModifiers_StatusModifier.prototype,{
	getText: function() {
		return "";
	}
	,__class__: worldElements_creatures_statusEffects_StatusEffect
});
var worldElements_creatures_statusEffects_Poison = function(creature) {
	worldElements_creatures_statusEffects_StatusEffect.call(this,creature);
};
worldElements_creatures_statusEffects_Poison.__name__ = true;
worldElements_creatures_statusEffects_Poison.__super__ = worldElements_creatures_statusEffects_StatusEffect;
worldElements_creatures_statusEffects_Poison.prototype = $extend(worldElements_creatures_statusEffects_StatusEffect.prototype,{
	init: function() {
		this.name = "Poisoned";
		this.hitEvery = 3;
		this.hitInTurns = 1;
		this.hitsUntilEnd = 4;
	}
	,onTurn: function() {
		if(this.hitInTurns <= 0) {
			this.hitsUntilEnd -= 1;
			this.hitInTurns = this.hitEvery;
			var interesting = this.creature.isInterestingForPlayer();
			if(interesting) {
				this.creature.world.info.addInfo("Poison dealt 1 damage to " + this.creature.getNameToUse() + ".");
			}
			this.creature.stats.hp -= 1;
			if(this.hitsUntilEnd <= 0) {
				this.ended = true;
				if(interesting) {
					this.creature.world.info.addInfo("Then, " + this.creature.getReferenceToUse() + " " + this.creature.getWereOrWas() + " no longer poisoned.");
				}
			}
		} else {
			this.hitInTurns -= 1;
		}
	}
	,getText: function() {
		return "Deals one damage every " + (this.hitEvery + 1) + " turns. Next damage in " + (this.hitInTurns + 1) + " turns. Ends after " + this.hitsUntilEnd + " more hits.";
	}
	,__class__: worldElements_creatures_statusEffects_Poison
});
var worldElements_creatures_statusEffects_SplitOnByGoblin = function(creature) {
	worldElements_creatures_statusEffects_StatusEffect.call(this,creature);
};
worldElements_creatures_statusEffects_SplitOnByGoblin.__name__ = true;
worldElements_creatures_statusEffects_SplitOnByGoblin.__super__ = worldElements_creatures_statusEffects_StatusEffect;
worldElements_creatures_statusEffects_SplitOnByGoblin.prototype = $extend(worldElements_creatures_statusEffects_StatusEffect.prototype,{
	init: function() {
		this.name = "Spit on by a goblin";
		this.goesAwayAfter = 50;
	}
	,onTurn: function() {
		if(this.goesAwayAfter <= 0) {
			if(this.creature.isInterestingForPlayer()) {
				this.creature.world.info.addInfo("It was no longer possible to see or smell the goblin spit on " + this.creature.getReferenceToUse() + ".");
			}
			this.ended = true;
		} else {
			this.goesAwayAfter -= 1;
		}
	}
	,getText: function() {
		return "All goblins are aggressive to you! Ends after " + this.goesAwayAfter + " turns.";
	}
	,makesCreatureAggressive: function(creature) {
		return js_Boot.__instanceof(creature,worldElements_creatures_Goblin);
	}
	,__class__: worldElements_creatures_statusEffects_SplitOnByGoblin
});
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {};
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=game_js.js.map