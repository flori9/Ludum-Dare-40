// Generated by Haxe 3.4.4
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Color = { __ename__ : true, __constructs__ : ["Red","Green","Blue","Black","White","Gray","LightBlue","Purple","Yellow"] };
Color.Red = ["Red",0];
Color.Red.toString = $estr;
Color.Red.__enum__ = Color;
Color.Green = ["Green",1];
Color.Green.toString = $estr;
Color.Green.__enum__ = Color;
Color.Blue = ["Blue",2];
Color.Blue.toString = $estr;
Color.Blue.__enum__ = Color;
Color.Black = ["Black",3];
Color.Black.toString = $estr;
Color.Black.__enum__ = Color;
Color.White = ["White",4];
Color.White.toString = $estr;
Color.White.__enum__ = Color;
Color.Gray = ["Gray",5];
Color.Gray.toString = $estr;
Color.Gray.__enum__ = Color;
Color.LightBlue = ["LightBlue",6];
Color.LightBlue.toString = $estr;
Color.LightBlue.__enum__ = Color;
Color.Purple = ["Purple",7];
Color.Purple.toString = $estr;
Color.Purple.__enum__ = Color;
Color.Yellow = ["Yellow",8];
Color.Yellow.toString = $estr;
Color.Yellow.__enum__ = Color;
var Drawer = function(stage) {
	this.stage = stage;
	this.wallGraphics = new PIXI.Graphics();
	stage.addChild(this.wallGraphics);
	this.bitmaps = [];
	var _g = 0;
	while(_g < 24) {
		var i = _g++;
		this.bitmaps[i] = [];
		var _g1 = 0;
		while(_g1 < 50) {
			var j = _g1++;
			var bitmap = new PIXI.extras.BitmapText("",{ font : "font", tint : 16777215});
			this.bitmaps[i][j] = bitmap;
			bitmap.position.set(j * 15,i * 25 - 5);
			stage.addChild(bitmap);
		}
	}
};
Drawer.__name__ = true;
Drawer.colorToInt = function(color) {
	switch(color[1]) {
	case 0:
		return 16711680;
	case 1:
		return 65280;
	case 2:
		return 255;
	case 3:
		return 0;
	case 4:
		return 16777215;
	case 5:
		return 8421504;
	case 6:
		return 4376052;
	case 7:
		return 9060294;
	case 8:
		return 16776960;
	}
};
Drawer.prototype = {
	clear: function() {
		var _g = 0;
		while(_g < 24) {
			var i = _g++;
			var _g1 = 0;
			while(_g1 < 50) {
				var j = _g1++;
				this.bitmaps[i][j].text = "";
			}
		}
		this.wallGraphics.clear();
	}
	,setWorldView: function(screenX,screenY,worldX,worldY,width,height) {
		this.screenX = screenX;
		this.screenY = screenY;
		this.worldX = worldX;
		this.worldY = worldY;
		this.worldWidth = width;
		this.worldHeight = height;
	}
	,setWorldCharacter: function(x,y,character,color) {
		if(color == null) {
			color = 16777215;
		}
		if(x >= this.worldX && y >= this.worldY && x < this.worldX + this.worldWidth && y < this.worldY + this.worldHeight) {
			this.setCharacter(x - this.worldX + this.screenX,y - this.worldY + this.screenY,character,color);
		}
	}
	,setWorldWall: function(x,y,color) {
		if(color == null) {
			color = 16777215;
		}
		if(x >= this.worldX && y >= this.worldY && x < this.worldX + this.worldWidth && y < this.worldY + this.worldHeight) {
			this.setBackground(x - this.worldX + this.screenX,y - this.worldY + this.screenY,color);
		}
	}
	,setCharacter: function(x,y,character,color) {
		if(color == null) {
			color = 16777215;
		}
		if(x < 0 || y < 0 || x >= 50 || y >= 24) {
			return;
		}
		this.bitmaps[y][x].text = character;
		this.bitmaps[y][x].tint = color;
	}
	,setBackground: function(x,y,color) {
		if(color == null) {
			color = 16777215;
		}
		if(x < 0 || y < 0 || x >= 50 || y >= 24) {
			return;
		}
		this.wallGraphics.beginFill(color);
		this.wallGraphics.drawRect(x * 15,y * 25,15,25);
		this.wallGraphics.endFill();
	}
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
};
var Game = function(application,stage,gameRect) {
	this.application = application;
	this.stage = stage;
	this.rect = gameRect;
	this.drawer = new Drawer(stage);
	this.keyboard = new Keyboard();
	this.world = new World(this.drawer);
	this.player = new Player(this.keyboard,this.world,this);
	this.drawer.clear();
	this.world.draw();
};
Game.__name__ = true;
Game.prototype = {
	update: function(timeMod) {
		this.keyboard.update();
		this.player.update();
		this.postUpdate();
	}
	,postUpdate: function() {
		this.keyboard.postUpdate();
	}
	,beforeStep: function() {
		this.drawer.clear();
	}
	,afterStep: function() {
		this.world.update();
	}
};
var GameLoader = function(then) {
	this.loader = new PIXI.loaders.Loader();
	this.loader.add("fonts/font-export.fnt");
	this.loader["use"](function(res,next) {
		next();
	});
	this.loader.load(then);
};
GameLoader.__name__ = true;
GameLoader.prototype = {
	update: function() {
		console.log(this.loader.progress + "% loaded");
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
var Keyboard = function() {
	var _gthis = this;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var i = _g1++;
		_g.push(false);
	}
	this.pressed = _g;
	var _g11 = [];
	var _g2 = 0;
	while(_g2 < 256) {
		var i1 = _g2++;
		_g11.push(false);
	}
	this.down = _g11;
	window.addEventListener("keydown",function(event) {
		var keyCode = event.keyCode;
		if(keyCode < 256) {
			_gthis.pressed[keyCode] = true;
			_gthis.down[keyCode] = true;
		}
	},false);
	window.addEventListener("keyup",function(event1) {
		var keyCode1 = event1.keyCode;
		if(keyCode1 < 256) {
			_gthis.down[keyCode1] = false;
		}
	},false);
};
Keyboard.__name__ = true;
Keyboard.prototype = {
	update: function() {
	}
	,postUpdate: function() {
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			this.pressed[i] = false;
		}
	}
};
var pixi_plugins_app_Application = function() {
	this._animationFrameId = null;
	this.pixelRatio = 1;
	this.autoResize = true;
	this.transparent = false;
	this.antialias = false;
	this.forceFXAA = false;
	this.roundPixels = false;
	this.legacy = false;
	this.clearBeforeRender = true;
	this.preserveDrawingBuffer = false;
	this.backgroundColor = 16777215;
	this.width = window.innerWidth;
	this.height = window.innerHeight;
	this.position = "static";
};
pixi_plugins_app_Application.__name__ = true;
pixi_plugins_app_Application.prototype = {
	start: function(rendererType,parentDom,canvasElement) {
		if(rendererType == null) {
			rendererType = "auto";
		}
		if(canvasElement == null) {
			this.canvas = window.document.createElement("canvas");
			this.canvas.style.width = this.width + "px";
			this.canvas.style.height = this.height + "px";
			this.canvas.style.position = this.position;
		} else {
			this.canvas = canvasElement;
		}
		if(this.autoResize) {
			window.onresize = $bind(this,this._onWindowResize);
		}
		var renderingOptions = { };
		renderingOptions.width = this.width | 0;
		renderingOptions.height = this.height | 0;
		renderingOptions.view = this.canvas;
		renderingOptions.backgroundColor = this.backgroundColor;
		renderingOptions.resolution = this.pixelRatio;
		renderingOptions.antialias = this.antialias;
		renderingOptions.forceFXAA = this.forceFXAA;
		renderingOptions.autoResize = this.autoResize;
		renderingOptions.transparent = this.transparent;
		renderingOptions.clearBeforeRender = this.clearBeforeRender;
		renderingOptions.preserveDrawingBuffer = this.preserveDrawingBuffer;
		renderingOptions.roundPixels = this.roundPixels;
		renderingOptions.legacy = this.legacy;
		if(rendererType == null) {
			this.app = new PIXI.Application(renderingOptions);
		} else if(rendererType == "canvas") {
			renderingOptions.forceCanvas = true;
			this.app = new PIXI.Application(renderingOptions);
		} else {
			this.app = new PIXI.Application(renderingOptions);
		}
		this.stage = this.app.stage;
		this.renderer = this.app.renderer;
		if(parentDom == null) {
			window.document.body.appendChild(this.app.view);
		} else {
			parentDom.appendChild(this.app.view);
		}
		this.app.ticker.add($bind(this,this._onRequestAnimationFrame));
	}
	,_onWindowResize: function(event) {
		this.width = window.innerWidth;
		this.height = window.innerHeight;
		this.app.renderer.resize(this.width,this.height);
		this.canvas.style.width = this.width + "px";
		this.canvas.style.height = this.height + "px";
		if(this.onResize != null) {
			this.onResize();
		}
	}
	,_onRequestAnimationFrame: function() {
		if(this.onUpdate != null) {
			this.onUpdate(this.app.ticker.deltaTime);
		}
	}
};
var Main = function() {
	pixi_plugins_app_Application.call(this);
	this.init();
};
Main.__name__ = true;
Main.main = function() {
	new Main();
};
Main.__super__ = pixi_plugins_app_Application;
Main.prototype = $extend(pixi_plugins_app_Application.prototype,{
	init: function() {
		var _gthis = this;
		this.autoResize = false;
		this.onUpdate = $bind(this,this.update);
		this.backgroundColor = 0;
		this.clearBeforeRender = true;
		this.width = 750;
		this.height = 600;
		this.initConfig();
		pixi_plugins_app_Application.prototype.start.call(this);
		this.gameRect = new common_Rectangle(0,0,750,600);
		this.loader = new GameLoader(function() {
			console.log("loaded");
			_gthis.loader = null;
			_gthis.game = new Game(_gthis,_gthis.stage,_gthis.gameRect);
		});
		this.canvas.addEventListener("contextmenu",function(ev) {
			ev.preventDefault();
			return false;
		});
	}
	,initConfig: function() {
		try {
			var params = haxe_web_Request.getParams();
		} catch( e ) {
		}
	}
	,update: function(elapsedTime) {
		if(this.game != null) {
			this.game.update(elapsedTime);
		} else if(this.loader != null) {
			this.loader.update();
		}
	}
});
Math.__name__ = true;
var Player = function(keyboard,world,game) {
	this.keyboard = keyboard;
	this.world = world;
	this.game = game;
	this.ownBody = new worldElements_creatures_Human(world,new common_Point(1,1));
	world.addElement(this.ownBody);
	this.controllingBody = this.ownBody;
};
Player.__name__ = true;
Player.prototype = {
	update: function() {
		var xMove = 0;
		var yMove = 0;
		if(this.keyboard.pressed[37]) {
			--xMove;
		}
		if(this.keyboard.pressed[39]) {
			++xMove;
		}
		if(this.keyboard.pressed[38]) {
			--yMove;
		}
		if(this.keyboard.pressed[40]) {
			++yMove;
		}
		var moveDirection = null;
		if(xMove == -1) {
			moveDirection = common_Direction.Left;
		} else if(xMove == 1) {
			moveDirection = common_Direction.Right;
		} else if(yMove == -1) {
			moveDirection = common_Direction.Up;
		} else if(yMove == 1) {
			moveDirection = common_Direction.Down;
		}
		if(moveDirection != null) {
			if(this.controllingBody.movement.canMove(this.world,this.controllingBody,moveDirection)) {
				this.game.beforeStep();
				this.controllingBody.movement.moveInDirection(this.world,this.controllingBody,moveDirection);
				this.controllingBody.hasMoved = true;
				this.game.afterStep();
			}
		}
	}
};
var World = function(drawer) {
	this.height = 23;
	this.width = 50;
	this.drawer = drawer;
	this.elements = [];
	var _g = [];
	var _g2 = 0;
	var _g1 = this.width;
	while(_g2 < _g1) {
		var i = _g2++;
		var _g3 = [];
		var _g5 = 0;
		var _g4 = this.height;
		while(_g5 < _g4) {
			var j = _g5++;
			_g3.push([]);
		}
		_g.push(_g3);
	}
	this.elementsByPosition = _g;
	this.elements.push(new worldElements_Wall(this,new common_Point(0,0)));
	this.elements.push(new worldElements_Wall(this,new common_Point(1,0)));
};
World.__name__ = true;
World.prototype = {
	addElement: function(element) {
		this.elements.push(element);
	}
	,addToElementsAtPosition: function(element,position) {
		this.elementsByPosition[position.x][position.y].push(element);
	}
	,removeFromElementsAtPosition: function(element,position) {
		HxOverrides.remove(this.elementsByPosition[position.x][position.y],element);
	}
	,update: function() {
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.update();
		}
		this.draw();
	}
	,draw: function() {
		this.drawer.setWorldView(0,1,0,0,this.width,this.height);
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.draw(this.drawer);
		}
	}
	,positionInDirection: function(position,direction) {
		var newPosition = new common_Point(position.x,position.y);
		switch(direction[1]) {
		case 0:
			newPosition.x -= 1;
			break;
		case 1:
			newPosition.x += 1;
			break;
		case 2:
			newPosition.y -= 1;
			break;
		case 3:
			newPosition.y += 1;
			break;
		}
		if(this.isPositionInWorld(newPosition)) {
			return newPosition;
		} else {
			return null;
		}
	}
	,isPositionInWorld: function(position) {
		if(position.x >= 0 && position.y >= 0 && position.x < this.width) {
			return position.y < this.height;
		} else {
			return false;
		}
	}
	,elementsAtPosition: function(position) {
		return this.elementsByPosition[position.x][position.y];
	}
};
var common_ArrayExtensions = function() { };
common_ArrayExtensions.__name__ = true;
common_ArrayExtensions.any = function(array,fn) {
	var _g = 0;
	while(_g < array.length) {
		var val = array[_g];
		++_g;
		if(fn(val)) {
			return true;
		}
	}
	return false;
};
var common_Rectangle = function(x,y,width,height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
common_Rectangle.__name__ = true;
var common_Point = function(x,y) {
	this.x = x;
	this.y = y;
};
common_Point.__name__ = true;
var common_Direction = { __ename__ : true, __constructs__ : ["Left","Right","Up","Down"] };
common_Direction.Left = ["Left",0];
common_Direction.Left.toString = $estr;
common_Direction.Left.__enum__ = common_Direction;
common_Direction.Right = ["Right",1];
common_Direction.Right.toString = $estr;
common_Direction.Right.__enum__ = common_Direction;
common_Direction.Up = ["Up",2];
common_Direction.Up.toString = $estr;
common_Direction.Up.__enum__ = common_Direction;
common_Direction.Down = ["Down",3];
common_Direction.Down.toString = $estr;
common_Direction.Down.__enum__ = common_Direction;
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
};
var haxe_web_Request = function() { };
haxe_web_Request.__name__ = true;
haxe_web_Request.getParams = function() {
	var get = HxOverrides.substr(window.location.search,1,null);
	var params = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = new EReg("[&;]","g").split(get);
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var pl = p.split("=");
		if(pl.length < 2) {
			continue;
		}
		var name = pl.shift();
		var key = decodeURIComponent(name.split("+").join(" "));
		var s = pl.join("=");
		var value = decodeURIComponent(s.split("+").join(" "));
		if(__map_reserved[key] != null) {
			params.setReserved(key,value);
		} else {
			params.h[key] = value;
		}
	}
	return params;
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var worldElements_WorldElement = function(world,position) {
	this.world = world;
	this.set_position(position);
	this.character = "";
	this.color = Drawer.colorToInt(Color.White);
	this.init();
};
worldElements_WorldElement.__name__ = true;
worldElements_WorldElement.prototype = {
	get_isBlocking: function() {
		return false;
	}
	,set_position: function(newPosition) {
		if(this.position != null) {
			this.world.removeFromElementsAtPosition(this,this.position);
		}
		this.position = newPosition;
		this.world.addToElementsAtPosition(this,newPosition);
		return this.position;
	}
	,init: function() {
	}
	,update: function() {
	}
	,draw: function(drawer) {
		drawer.setWorldCharacter(this.position.x,this.position.y,this.character,this.color);
	}
};
var worldElements_Creature = function(world,position) {
	this.hasMoved = false;
	worldElements_WorldElement.call(this,world,position);
};
worldElements_Creature.__name__ = true;
worldElements_Creature.__super__ = worldElements_WorldElement;
worldElements_Creature.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return true;
	}
	,init: function() {
		this.movement = new worldElements_movement_BasicMovement();
	}
	,update: function() {
		worldElements_WorldElement.prototype.update.call(this);
		if(!this.hasMoved) {
			this.movement.move(this.world,this);
			this.hasMoved = true;
		}
	}
});
var worldElements_Wall = function(world,position) {
	worldElements_WorldElement.call(this,world,position);
};
worldElements_Wall.__name__ = true;
worldElements_Wall.__super__ = worldElements_WorldElement;
worldElements_Wall.prototype = $extend(worldElements_WorldElement.prototype,{
	get_isBlocking: function() {
		return true;
	}
	,draw: function(drawer) {
		drawer.setWorldWall(this.position.x,this.position.y,this.color);
	}
});
var worldElements_creatures_Human = function(world,position) {
	worldElements_Creature.call(this,world,position);
};
worldElements_creatures_Human.__name__ = true;
worldElements_creatures_Human.__super__ = worldElements_Creature;
worldElements_creatures_Human.prototype = $extend(worldElements_Creature.prototype,{
	init: function() {
		worldElements_Creature.prototype.init.call(this);
		this.color = Drawer.colorToInt(Color.LightBlue);
		this.character = "@";
	}
});
var worldElements_movement_Movement = function() { };
worldElements_movement_Movement.__name__ = true;
worldElements_movement_Movement.prototype = {
	canMove: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			var elementsHere = world.elementsAtPosition(newPosition);
			return !common_ArrayExtensions.any(elementsHere,function(e) {
				return e.get_isBlocking();
			});
		}
		return false;
	}
	,move: function(world,creature) {
	}
	,moveInDirection: function(world,creature,direction) {
		var newPosition = world.positionInDirection(creature.position,direction);
		if(newPosition != null) {
			creature.set_position(newPosition);
		}
	}
};
var worldElements_movement_BasicMovement = function() {
};
worldElements_movement_BasicMovement.__name__ = true;
worldElements_movement_BasicMovement.__super__ = worldElements_movement_Movement;
worldElements_movement_BasicMovement.prototype = $extend(worldElements_movement_Movement.prototype,{
});
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
var __map_reserved = {};
Main.main();
})();

//# sourceMappingURL=game_js.js.map